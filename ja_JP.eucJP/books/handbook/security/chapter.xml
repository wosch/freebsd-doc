<?xml version="1.0" encoding="euc-jp"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Japanese Documentation Project

     Original revision: r24771
     $FreeBSD$
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="security">
  <info><title>セキュリティ</title>
    <authorgroup>
      <author><personname><firstname>Matthew</firstname><surname>Dillon</surname></personname><contrib>本章の基にした security(7) マニュアルページの執筆: </contrib></author>
    </authorgroup>
  </info>

  
  <indexterm><primary>セキュリティ</primary></indexterm>

  <para><emphasis>訳: &a.jp.hino;、(jpman プロジェクトの成果を利用させ
    ていただきました)。</emphasis></para>

  <sect1 xml:id="security-synopsis">
    <title>この章では</title>

    <para>この章では、基本的なシステムセキュリティの考え方、
      覚えておくべき一般的なルールを紹介し、
      &os; における高度な話題について簡単に説明します
      ここで扱う話題の多くは、
      一般的なシステムやインターネットセキュリティにもあてはまります。
      インターネットはもはや、誰もが親切な隣人であろうとする
      <quote>友好的な</quote> 場ではありません。
      あなたのシステムを安全に保つことは、
      あなたのデータ、知的財産、時間、その他を、
      ハッカーやその同類から守るためには欠かせません。</para>

    <para>&os; は、
      システムとネットワークの整合性と安全性を確実にする仕組みと一連のユーティリティを提供しています。</para>

    <para>この章を読むと、以下のことがわかります。</para>

    <itemizedlist>
      <listitem>
	<para>&os;
	  に関する基本的なシステムセキュリティの考え方</para>
      </listitem>

      <listitem>
	<para><acronym>DES</acronym> や <acronym>MD5</acronym> のような、
	  &os; で利用できるさまざまな暗号化手法について</para>
      </listitem>

      <listitem>
	<para>ワンタイムパスワード認証の設定方法</para>
      </listitem>

      <listitem>
	<para><command>inetd</command> と組み合わせて
	  <acronym>TCP</acronym> Wrappers を設定する方法</para>
      </listitem>

      <listitem>
	<para>&os; 5.0 より前のリリースにおける、
	  <application>KerberosIV</application> の設定方法</para>
      </listitem>

      <listitem>
	<para>&os; 5.0 以降のリリースにおける、
	  <application>Kerberos5</application> の設定方法</para>
      </listitem>

      <listitem>
	<para>IPsec および FreeBSD/&windows; コンピュータの間で
	  <acronym>VPN</acronym> の設定方法</para>
      </listitem>

      <listitem>
	<para>&os; で使われている <acronym>SSH</acronym> である
	  <application>OpenSSH</application> の設定および使用方法</para>
      </listitem>

      <listitem>
	<para>ファイルシステムの <acronym>ACL</acronym> (アクセス制御リスト)
	  とは何か、またその使用法</para>
      </listitem>

      <listitem>
	<para><application>Portaudit</application>
	  ユーティリティを使って、Ports Collection
	  からインストールされたサードパーティ製ソフトウェア packages
	  を監査する方法</para>
      </listitem>

      <listitem>
	<para>公開される &os; セキュリティ勧告の利用方法</para>
      </listitem>

      <listitem>
	<para>プロセスアカウンティングがどのようなものか、
	  &os; 上で有効にする方法について</para>
      </listitem>
    </itemizedlist>

    <para>この章を読む前に、次のことが必要になります。</para>

    <itemizedlist>
      <listitem>
	<para>&os; およびインターネットの基本概念の理解</para>
      </listitem>
    </itemizedlist>

<!--    <para>Additional security topics are covered throughout this book.
      For example, Mandatory Access Control is discussed in <xref
      linkend="mac"/> and Internet Firewalls are discussed in <xref
      linkend="firewalls"/>.</para> -->
  </sect1>

  <sect1 xml:id="security-intro">
    <title>はじめに</title>

    <para>セキュリティとは、システム管理者をいつも悩ませる仕事の一つです。
      すべての BSD &unix; マルチユーザシステムは、
      従来からいくつかのセキュリティ機構を備えていますが、
      ユーザを疑心暗鬼に陥らせないように追加のセキュリティ機構を構築し
      保守する仕事はおそらく、システム管理者としてもっとも大きな責務の一つでしょう。
      マシンの安全性に反映されるのは、管理者が作業したことだけです。
      またセキュリティ問題は、快適な環境に必要なものと競合します。
      一般に &unix; システムは膨大な数のプロセスを同時に動作させることができ、
      そのプロセスの大部分は、サーバ &mdash;
      外部から接続し、通信するものとして動作します。
      かつてのミニコンとメインフレームがデスクトップにとってかわり、
      さらにコンピュータが相互に接続されたネットワークを形成するようになった今日、
      セキュリティは一層大きな関心事になってきています。</para>

    <para>セキュリティを実装するには、
      タマネギのように階層化する手法
      (a layered <quote>onion</quote> approach)
      が最適です。
      どうすれば良いのか簡単に説明すると、
      便利な機能と同じ数だけセキュリティの階層を作り、
      システムへの侵入を注意深く監視するのです。
      あなたはセキュリティを過度に厳重にしたり、
      侵入の監視に時間をとられたいとは思わないでしょう。
      この侵入の発見という部分は、
      あらゆるセキュリティ機構において最も重要な部分の一つなのです。
      たとえば、システムの各バイナリに
      <literal>schg</literal> フラグ (&man.chflags.1; 参照)
      を設定するのは、大して意味がありません。
      フラグを設定すると一時的にバイナリが保護され、
      侵入してきた攻撃者によってシステムに加えられる変更のうち、
      容易に検出可能な変更は行なえなくなります。
      しかしその結果として、セキュリティ機構がその侵入者を検出することも
      まったくできなくなってしまうでしょう。</para>

    <para>また、システムセキュリティには、
      さまざまな形での攻撃に対処することとも関係しています。
      攻撃の中には <systemitem class="username">root</systemitem>
      権限を奪おう (<quote>root 権限を破る</quote>) とはしないけれども、
      クラッシュやシステムの不安定状態を引き起こそうとするものもあります。
      このセキュリティ問題は、いくつかに分類することが可能です。</para>

    <orderedlist>
      <listitem>
	<para>サービス妨害攻撃 (denial of service attack)</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントの不正利用 (user account compromise)</para>
      </listitem>

      <listitem>
	<para>アクセス可能なサーバを使った root 権限の不正利用</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントを経由した root 権限の不正使用</para>
      </listitem>

      <listitem>
	<para>バックドアの設置</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS 攻撃</primary>
      <see>サービス妨害 (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>DoS 攻撃</secondary>
      <see>サービス妨害 (DoS)</see>
    </indexterm>
    <indexterm><primary>サービス妨害 (DoS)</primary></indexterm>

    <para>サービス妨害攻撃 (DoS 攻撃) とは、
      マシンから必要な資源を奪う行為です。
      通常、サービス妨害攻撃はそのマシンで実行されるサーバや
      ネットワークスタックを過負荷状態にしてマシンをクラッシュさせたり、
      マシンを使えなくしたりするような力任せの方法です。
      サービス妨害攻撃の中には、
      ネットワークスタックのバグを利用して、
      パケット一つでマシンをクラッシュさせようとするものもあります。
      後者には、カーネルにバグ修正を施すことによってのみ対応することができます。
      サーバプロセスに対する攻撃は、オプションを適切に指定することによって、
      攻撃されている状況でサーバプロセスの負荷上昇に限界を設定することで
      対応できる場合が多いです。これらに比べると、
      ネットワークへの力任せの攻撃への対応はずっと難しくなります。
      たとえば、偽造パケットによる攻撃 (spoof-packet attack) は、
      インターネットからシステムを切り離す以外の方法で
      防ぐことはほとんど不可能です。
      この攻撃によって、マシンを落としてしまうことはできないかもしれませんが、
      接続しているインターネット回線を飽和させてしまうことはできます。</para>

    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>アカウント不正利用</secondary>
    </indexterm>

    <para>ユーザアカウントの不正利用は、
      サービス妨害攻撃よりもずっとよくある問題です。
      このご時勢でも、自分たちのマシンで標準の
      <application>telnetd</application>,
      <application>rlogind</application>,
      <application>rshd</application>, <application>ftpd</application>
      サーバを実行させているシステ
      ム管理者は多いのです。これらのサーバは、デフォルトでは、暗号化さ
      れたコネクション上で動作していません。その結果、抱えているユーザ
      数が標準くらいであれば、リモートログイン (そのシステムにログイン
      するには最も普通で便利な方法です) しているユーザのうち一人以上は、
      パスワードを覗き見られてしまうでしょう。システム管理者が注意深い
      人ならば、たとえログインが成功していたとしても、リモートアクセス
      ログを解析して、疑わしい送信元アドレスを探すものです。</para>

    <para>ひとたび攻撃者がユーザアカウントへのアクセス権を入手したら、
      攻撃者は <systemitem class="username">root</systemitem> 権限を破れると仮定するべきです。
      しかし、セキュリティを十分維持し、手入れの行き届いたシステムにおい
      ては、あるユーザアカウントへのアクセスが可能となっても、
      必ずしも攻撃者に <systemitem class="username">root</systemitem>
      へのアクセス権を与えるとは限りません。この違いは重要です。
      というのは、一般的に
      <systemitem class="username">root</systemitem> へのアクセス権がなければ、
      攻撃者は自分の侵入の痕跡を隠蔽することができませんし、
      そのユーザのファイルを引っかき回したり、
      マシンをクラッシュさせたりするのがせいぜいです。
      ユーザアカウントの不正利用はめずらしいことではありません。
      なぜなら一般ユーザは、
      システム管理者ほど注意を払わない傾向があるからです。</para>

    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>裏口 (バックドア)</secondary>
    </indexterm>

    <para>システム管理者は、あるマシン上で <systemitem class="username">root</systemitem>
      権限を奪取する方法は、
      潜在的に何通りもあるということを心しておかねばなりません。
      攻撃者は <systemitem class="username">root</systemitem>
      のパスワードを知っているかもしれませんし、
      攻撃者が <systemitem class="username">root</systemitem>
      権限で実行されているサーバのバグを見つけ、
      ネットワーク接続を介して
      <systemitem class="username">root</systemitem> 権限を破ることができるかもしれません。
      また、攻撃者は suid-root プログラムに存在するバグを知っていて、
      ユーザアカウントを破れば
      <systemitem class="username">root</systemitem> 権限を奪取できるかもしれません。
      攻撃者があるマシン上で
      <systemitem class="username">root</systemitem> 権限を破る方法を知ったならば、
      攻撃者は裏口を用意する必要がありません。
      これまでに発見され、ふさがれた <systemitem class="username">root</systemitem>
      の穴の多くには、攻撃者が自分のしたことの痕跡を消そうとした作業が、
      かなりの割合で含まれています。
      そのため、ほとんどの攻撃者は裏口を作るのです。裏口は、
      攻撃者がたやすくシステムへの
      <systemitem class="username">root</systemitem> アクセスを再び得られるようにしますが、
      有能な管理者に侵入を検知する便利な手段を与えるものでもあります。
      攻撃者に裏口を作らせないようにするということは、
      セキュリティにとっては実際には良くないことかもしれません。
      なぜなら、攻撃者が最初に見つけて侵入してきたセキュリティホールは
      ふさがれないからです。</para>

    <para>セキュリティを改善する方法は、常に、
      タマネギの皮のように階層化する手法
      (a multi-layered <quote>onion peel</quote> approach)
      で実装されるべきです。これらは次のように分類できます。</para>

    <orderedlist>
      <listitem>
	<para><systemitem class="username">root</systemitem>
	  とスタッフのアカウントの安全性を高める。</para>
      </listitem>

      <listitem>
	<para><systemitem class="username">root</systemitem> の安全性を高める &ndash;
	  <systemitem class="username">root</systemitem> 権限で動作するサーバと
	  suid/sgid バイナリ。</para>
      </listitem>

      <listitem>
	<para>ユーザアカウントの安全性を高める。</para>
      </listitem>

      <listitem>
	<para>パスワードファイルの安全性を高める。</para>
      </listitem>

      <listitem>
	<para>カーネルのコア、raw デバイス、ファイルシステムの安全性を
	高める。</para>
      </listitem>

      <listitem>
	<para>システムに対して行なわれた、不適切な変更をすばやく検出す
	る。</para>
      </listitem>

      <listitem>
	<para>必要と思われる以上の対応をとる (paranoia)。</para>
      </listitem>
    </orderedlist>

    <para>本章の次の節では、上記の各項目についてより深く掘り下げていき
      ます。</para>
  </sect1>

  <sect1 xml:id="securing-freebsd">
    <title>&os; の安全性を高める</title>
    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>&os; の安全性を高める</secondary>
    </indexterm>

    <note>
      <title>コマンド対プロトコル</title>
      <para>この文書を通して、アプリケーションを指すのには
	<application>太字</application> を使い、
	コマンドを指す場合には、<command>等幅</command> フォントを使います。
	プロトコルは通常のフォントで表します。
	このような書体による区別は、
	プロトコルであると同時にコマンドでもある
	ssh などに対して有効です。</para>
    </note>

  <indexterm>
    <primary>セキュリティ</primary>
    <secondary>安全性を高める</secondary>
  </indexterm>

    <para>以下の節では、本章の<link linkend="security-intro">前節
      </link>でとりあげた &os; システムの安全性を高める方法について
      述べます。</para>

    <sect2 xml:id="securing-root-and-staff">
      <title><systemitem class="username">root</systemitem>
	アカウントとスタッフアカウントの安全性を高める</title>
      <indexterm>
	<primary><command>su</command></primary>
      </indexterm>

      <para><systemitem class="username">root</systemitem>
	のアカウントの安全性を確保しないうちから
	スタッフのアカウントの安全性をうんぬんしてもしかたがありません。
	ほとんどのシステムでは、<systemitem class="username">root</systemitem>
	アカウントに割り当てたパスワードが 1 つあり
	ます。まず最初にすべきことは、このパスワードは<emphasis>いつで
	も</emphasis>不正利用の危険に晒されていると仮定することです。これは
	<systemitem class="username">root</systemitem>
	のパスワードを消すべきだと言っているのではありません。
	<systemitem class="username">root</systemitem>
	のパスワードは、マシンにコンソールからアクセスするのには、
	ほとんどいつでも必要なものです。ここで言いたいのは、コンソール
	以外からは、そして可能なら &man.su.1; コマンドを実行する場合も
	<systemitem class="username">root</systemitem>
	のパスワードを使えないようにするべきである、ということで
	す。たとえば、あなたが使っている pty が、
	<filename>/etc/ttys</filename> ファイルで insecure と指定
	されているか確認してください。そうすると、
	<command>telnet</command> や <command>rlogin</command> 経由では
	<systemitem class="username">root</systemitem> で直接ログインできないようになります。
	これは、<filename>/etc/ssh/sshd_config</filename> を編集して
	<literal>PermitRootLogin</literal> に <literal>NO</literal>
	が設定されるようにすることで実現できます。
	<application>sshd</application> のような、別のログインサービス
	を使っている場合でも同様に、直接 <systemitem class="username">root</systemitem>
	へログインすることを許し
	ていないかどうか確認してください。すべてのアクセス手段 &mdash;
	たとえば FTP
	のようなサービスが、良くクラックの対象となることを考えましょう。
	<systemitem class="username">root</systemitem> への直接ログインは、
	システムコンソール経由でのみ可能であるべきなのです。</para>
      <indexterm>
	<primary><systemitem class="groupname">wheel</systemitem></primary>
      </indexterm>

      <para>また当然、システム管理者として自分が <systemitem class="username">root</systemitem>
	になれるようにしておく必要が
	ありますから、そのための穴をいくつか開けておきます。し
	かし、それらの穴を動作させるには、さらに追加のパスワード認証が
	必要であるようにしておくことが重要です。
	<systemitem class="username">root</systemitem> でアクセス可能と
	する方法の一つとして、適切なスタッフアカウントを
	(<filename>/etc/group</filename> 中の)
	<systemitem class="groupname">wheel</systemitem> グループに加えることがあります。
	<systemitem class="groupname">wheel</systemitem> グループに入っているスタッフメンバは
	<command>su</command> を使って
	<systemitem class="username">root</systemitem> になることが許されます。
	パスワードエントリにおいて、スタッフメンバを
	<systemitem class="groupname">wheel</systemitem> グループに置くことによって直接
	<systemitem class="groupname">wheel</systemitem>
	権限を与えてはいけません。スタッフメンバのアカウントは
	<systemitem class="groupname">staff</systemitem> グループに所属させるべきで、その上で
	<filename>/etc/group</filename> ファイルを通して
	<systemitem class="groupname">wheel</systemitem> グループに加えるべきです。実際に
	<systemitem class="username">root</systemitem> アクセスの必要なスタッフメンバのみ
	<systemitem class="groupname">wheel</systemitem> グループに置くようにすべきです。
	他の認証方法の場合、たとえば Kerberos を使用する場合には、
	<systemitem class="username">root</systemitem> アカウントの
	Kerberos <filename>.k5login</filename> ファイルを使えば、誰も
	<systemitem class="groupname">wheel</systemitem> グループに置く必要なく
	<systemitem class="username">root</systemitem> に &man.ksu.1;
	することを許可できます。このやり
	方はよりよい解決策なのかもしれません。なぜなら、
	<literal>wheel</literal> のメカニズムでは、侵入者がパスワード
	ファイルを手に入れ、スタッフアカウントのいずれか 1 つを破るこ
	とができると、
	<systemitem class="username">root</systemitem> を破ることがまだできてしまうからです。
	<systemitem class="groupname">wheel</systemitem> のメカニズムを用いる方が、
	何もしないよりは良いのですが、
	必ずしも最も安全な選択肢とは限りません。</para>

      <!-- XXX:
	This will need updating depending on the outcome of PR bin/71147.
	Personally I know what I'd like to see, which puts this in definite
	need of a rewrite, but we'll have to wait and see.  ceri@
      -->

      <para>スタッフのアカウント、また究極には
	<systemitem class="username">root</systemitem> アカウントの安全性
	を高める間接的な方法は、別のログインアクセスの方法を用いてスタッ
	フのアカウントの安全性を高め、その上でそのスタッフのアカウント
	の暗号化パスワードを <quote>アスタリスク化</quote>
	するものです。
	&man.vipw.8; コマンドを使えば、暗号化されたパスワードを
	<quote><literal>*</literal></quote> 1 文字に置き換えられます。
	このコマンドは、<filename>/etc/master.passwd</filename>
	ファイルとユーザ/パスワードデータベースを更新して、
	パスワード認証によるログインができないようにします。</para>

      <para>たとえば、次のスタッフアカウントを、</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>こう変更します。</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>暗号化されたパスワードは
	<quote><literal>*</literal></quote> と一致することがないので、
	この変更によって通常のログインはできなくなります。
	こうした後は、スタッフメンバは認証のために &man.kerberos.1; や
	公開鍵 / 秘密鍵の組を用いる &man.ssh.1; のような代わりとなる認
	証手段を利用しなければなりません。
	Kerberos のようなログイン機構を使う場合は、一般に Kerberos
	サーバを実行するマシンと自分のデスクトップワークステーションの安全性を確保しなければなりません。
	また ssh で公開鍵 / 秘密鍵の組を使う場合、
	一般に、<emphasis>ログイン元</emphasis>マシン (通常は自分のワー
	クステーション) の安全性を確保しなければなりません。ここで、
	&man.ssh-keygen.1; で公開鍵 / 秘密鍵の組を生成する際、鍵の組
	をパスワードで防御することにより、鍵の組への防御層を追加するこ
	ともできます。スタッフアカウントのパスワードを
	<quote>アスタリスク</quote> でつぶすことができると、
	管理者自身が設定
	した安全性の高い方法でしかスタッフメンバがログインできないこと
	も保証できます。こうして、多くの侵入者が使う重大なセキュリティ
	の穴である、
	安全性の低い無関係なマシンからネットワークを覗き見る方法を塞ぐようなセッションを提供する、
	安全性の高い暗号
	化されたコネクションを使うことを、スタッフメンバ全員に強制する
	ことができるのです。</para>

      <para>より間接的なセキュリティの仕組みでは、制限の強いサーバから
	制限の弱いサーバへログインすることを前提としています。たとえば、
	メインマシンで、様々な種類のサーバを実行させている場合、ワーク
	ステーションではそれらのサーバを実行させてはなりません。ワーク
	ステーションを十分に安全にしておくためには、実行するサーバの数
	を、一つもサーバが実行されていないというくらいにまでできる限り
	減らすべきです。また、パスワードで保護されたスクリーンセーバを
	走らせておくべきです。ワークステーションへの物理的アクセスが与
	えられたとすると、もちろん言うまでもなく、攻撃者は管理者が設定
	したいかなる種類のセキュリティをもうち破ることができるのです。
	このことは、管理者として必ず考えておかねばならない問題ですが、
	システム破りの大多数は、ネットワーク経由でリモートから、ワーク
	ステーションやサーバへの物理的アクセス手段を持たない人々によっ
	て行われるという事実もまた、念頭に置いておく必要があります。
	</para>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Kerberos のような方法を使うことで、
	スタッフアカウントのパ
	スワードの変更もしくは停止を一箇所で行なうことと、スタッフメン
	バがアカウントを持つすべてのマシンに即時にその効果を及ぼすこと
	が可能となります。スタッフメンバのアカウントが危険に晒されたと
	きに、すべてのマシンでスタッフメンバのパスワードを即座に変更す
	る能力を過小評価してはいけません。パスワードが分散されている状
	況では、N 台のマシンでパスワードを変更すると、てんやわんやの事
	態を招く可能性があります。Kerberos を使用すると、パスワードの
	再発行に制限 (re-passwording restriction) を課することもできま
	す。この機能を使うことにより、ある Kerberos チケットをしばらく
	経つとタイムアウトにすることができるだけでなく、一定期間 ( 例
	えば、1 ヶ月に 1 回) 経つと、ユーザに新しいパスワードを選ぶよ
	うに要求することもできます。</para>
    </sect2>

    <sect2>
      <title>root 権限で実行されているサーバと SUID/SGID バイナリの安全性を高める</title>
      <indexterm>
	<primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
	<primary>砂場 (sandbox)</primary>
      </indexterm>
      <indexterm>
	<primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>rlogind</application></primary>
      </indexterm>

      <para>用心深いシステム管理者は、自分に必要なサーバプロセスだけを
	過不足なく実行させるものです。サードパーティ製のサーバは、よくバグを持っ
	ていがちだということに注意して下さい。たとえば、古いバージョンの
	<application>imapd</application> や
	<application>popper</application>
	を実行させておくのは、全世界に万能の <systemitem class="username">root</systemitem>
	の切符を与えているようなものです。自分で注意深くチェックしていない
	サーバは、決して実行してはいけません。<systemitem class="username">root</systemitem>
	で実行させる必要のあるサーバはほとんどありません。たとえば、
	<application>ntalk</application>,
	<application>comsat</application>,
	<application>finger</application> デーモンを、専用ユーザの
	<firstterm>砂場 (sandbox)</firstterm> で実行させることができます。
	管理者が膨大な数の問題を経験していないのなら、
	この「砂場」は完
	璧ではありませんが、セキュリティに関するタマネギ的アプローチは
	ここでも成り立ちます。砂場で実行されているサーバプロセスを経由
	して侵入を果たすことができたとしても、攻撃者はさらに砂場から外
	に脱出しなければなりません。攻撃者が通過せねばならない層の数が
	増えれば増えるほど、それだけ攻撃者が侵入に成功する確率が減りま
	す。Root の抜け穴は歴史的に、基本システムサーバも含め、
	<systemitem class="username">root</systemitem>
	権限で実行されるほとんどすべてのサーバプロセスで発見されています。
	ユーザが <application>sshd</application> 経由でのみログインし、
	<application>telnetd</application>,
	<application>rshd</application>,
	<application>rlogind</application> 経由でログインすることが決
	してないマシンを稼働させているのであれば、それらのサービスを停
	止させて下さい!</para>

      <para>&os; では、今では <application>ntalkd</application>,
	<application>comsat</application>,
	<application>finger</application> は砂場で実行させることがデフォ
	ルトになっています。次に砂場で実行させるべきプログラムの候補と
	して、&man.named.8; があります。
	<filename>/etc/defaults/rc.conf</filename> ファイルには、
	<application>named</application> を砂場で実行するために必要な
	引数がコメントアウトされた形式で含まれています。新しいシステム
	をインストールしているか、それとも既存のシステムをアップグレー
	ドして使っているかに依存しますが、砂場として使用する特別のユー
	ザアカウントがインストールされていないかもしれません。用心深い
	システム管理者であれば、できるだけいつでも研究を怠らず、サーバ
	に砂場を仕込むものでしょう。</para>
      <indexterm>
	<primary><application>sendmail</application></primary>
      </indexterm>

      <para>通常、砂場で実行しないサーバが他にいくつかあります。
	<application>sendmail</application>,
	<application>popper</application>,
	<application>imapd</application>,
	<application>ftpd</application> などです。これらのうちいくつか
	のサーバには代わりとなるものがありますが、代わりのものをインス
	トールするには、あなたが思うより多くの仕事が必要になるかもしれ
	ません (便利さという要素がまたも勝利を収めるわけです)。これら
	のサーバは、<systemitem class="username">root</systemitem>
	権限で実行しなければばならないかもしれません。また、
	これらのサーバ経由で生じる侵入を検出するためには、他の仕組みに
	頼らなくてはならないかもしれません。</para>

      <para>システムの <systemitem class="username">root</systemitem>
	権限の潜在的な穴で他に大きなものには、シ
	ステムにインストールされた suid-root/sgid バイナリがあります。
	これらのバイナリは、<application>rlogin</application> のように、
	<filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, <filename>/usr/sbin</filename>
	に存在するものがほとんどです。100% 安全なものは存在しないとは
	いえ、システムデフォルトの siud/sgid バイナリは比較的安全とい
	えます。それでもなお、<systemitem class="username">root</systemitem>
	セキュリティホールがこれらのバイナリにときおり発見されています。
	1998 年に <application>xterm</application>
	(普通、suid 設定されています) を脆弱にしていた
	<literal>Xlib</literal> の <systemitem class="username">root</systemitem>
	セキュリティホールが見つかりました。
	安全である方がよいので、
	用心深いシステム管理者は残念に思いながらも、スタッフのみが実行
	する必要がある suid バイナリは、スタッフのみがアクセス可能な特
	別なグループに含めるように制限を加え、誰も使わない suid バイナ
	リは (<command>chmod 000</command> を実行して) 片付けてしまう
	でしょう。ディスプレイを持たないサーバは、一般的に
	<application>xterm</application> のバイナリを必要としません。
	sgid バイナリもほとんど同様の危険な存在になり得ます。侵入者が
	kmem に sgid されたバイナリを破ることができた場合、その侵入者
	は <filename>/dev/kmem</filename> を読み出すことができるように
	なるでしょう。つまり、暗号化されたパスワードファイルを読み出す
	ことができるようになるので、パスワードを持つどのアカウントをも、
	潜在的な危険に晒すことになります。他にも、
	<literal>kmem</literal> グループを破った侵入者が pty を通して
	送られたキーストロークを監視できるという危険があります。キース
	トロークには、安全な方法でログインするユーザが使っている pty
	も含まれます。
	<systemitem class="groupname">tty</systemitem> グループを破った侵入者は、ほぼ任意のユーザの
	tty へ書き込みができます。ユーザが端末プログラムやキーボードを
	シミュレーションする機能を持ったエミュレータを使っている場合、
	侵入者は潜在的に、結局そのユーザとして実行されるコマンドをユー
	ザの端末にエコーさせるデータストリームを生成できる可能性があり
	ます。</para>
    </sect2>

    <sect2 xml:id="secure-users">
      <title>ユーザアカウントの安全性を高める</title>

      <para>ユーザアカウントは、普通、安全性を高めることが最も困難です。
	スタッフに対しては、とても厳格なアクセス制限を強制しパスワードを
	<quote>アスタリスク</quote> で外すことができるでしょうが、
	管理者が
	持ちうる一般ユーザすべてのアカウントに対して同じことはできない
	かもしれません。管理者が十分に統率をとることができるなら、管理
	者は勝利し、ユーザのアカウントの安全を適切に確保できるかもしれ
	ません。それができないならば、よりいっそう気を配って一般ユーザ
	のアカウントを監視するよりほかありません。
	一般ユーザアカウントに対し ssh や Kerberos を利用することには、
	システム管理がさらに増えたりテクニカルサポートが必要に
	なるなどの問題があります。それでも、暗号化パスワードファイルと
	比較するとはるかに良い解です。</para>
    </sect2>

    <sect2>
      <title>パスワードファイルの安全性を高める</title>

      <para>できるだけ多くのパスワードを <literal>*</literal> で外し、
	それらのアカウントのアクセスには
	ssh や Kerberos を使うようにすることが、唯一の確実な方法です。
	暗号化パスワードファイル
	(<filename>/etc/spwd.db</filename>) は <systemitem class="username">root</systemitem>
	でのみ読み出し可能だけれども、
	たとえ、侵入者が root の書き込み権限は得られなくとも、
	読み出しアクセス権限を得ることは可能かもしれません。</para>

      <para>セキュリティスクリプトで常にパスワードファイルの変更をチェッ
	クし、報告するようにすべきです (<link linkend="security-integrity">ファイルの完全性のチェック</link>
	節参照)。</para>
    </sect2>

    <sect2>
      <title>カーネルのコア、raw デバイス、ファイルシステムの安全性を
      高める</title>

      <para><systemitem class="username">root</systemitem>
	の権限を破ると、攻撃者はほとんど何でもできますが、特に重宝さ
	れる特定の事柄もいくつかあります。たとえば、最近のカーネルは、組
	み込みのパケット覗き見デバイス (packet sniffing device) ドライ
	バを備えているものがほとんどです。&os; では
	<filename>bpf</filename> デバイスと呼ばれています。侵入者
	は普通、侵入済みのマシンでパケット覗き見プログラムを実行させよ
	うと試みます。侵入者にわざわざそういう機能を提供する必要はない
	ので、ほとんどのシステムで <filename>bpf</filename>
	デバイスを組み込むべきではありません。</para>

      <indexterm>
	<primary><command>sysctl</command></primary>
      </indexterm>
      <para><filename>bpf</filename> デバイスを外しても、
	<filename>/dev/mem</filename> と
	<filename>/dev/kmem</filename>
	という悩みの種がまだ残っています。この問題に関しては、侵入者は
	raw ディスクデバイスに書き込
	むこともできます。ほかにも、モジュールローダ、&man.kldload.8; とい
	う、別のカーネル機能があります。やる気まんまんの侵入者は、KLD
	モジュールを使って自分独自の <filename>bpf</filename>
	もしくはその他覗き見デバイス
	を動作中のカーネルにインストールできます。この問題を
	避けるため、システム管理者はカーネルをより高い安全レベル (
	securelevel)、少なくとも安全レベル 1 で実行させる必要がありま
	す。安全レベルは <command>sysctl</command> を使って
	<varname>kern.securelevel</varname>
	変数を操作して設定できます。ひとたび安全レベルに 1 を設定すると、raw デバ
	イスに対する書き込みアクセスは拒否され、たとえば
	<literal>schg</literal> のような特別な
	<command>chflags</command> フラグの機能が
	強制されます。システム起動に関わる重要なバイナリやディレクトリ、
	スクリプトファイルなど、安全レベルが設定されるまでの間に実行さ
	れるすべてのものに対しても、確実に <literal>schg</literal>
	フラグを設定してください。この設定をやり過ぎても
	構いませんが、より高い安全レベルで動作している場合、システムの
	アップグレードがはるかに困難になります。システムをより高い安全
	レベルで実行させるようにするが、すべてのシステムファイルとディ
	レクトリに <literal>schg</literal>
	フラグを設定しないというところで妥協するという手もあります。
	もう一つの可能性としては、単純に
	<filename>/</filename> および <filename>/usr</filename> を読み
	込み専用でマウントすることです。ここで特筆すべきことは、システ
	ムを守ろうとして厳しくしすぎると、侵入を検出するという非常に重
	要なことができなくなってしまうということです。</para>
    </sect2>

    <sect2 xml:id="security-integrity">
      <title>ファイルの完全性のチェック: バイナリ、設定ファイルなど
      </title>

      <para>ことこの問題に至ると、システム管理者にできることは、便利さ
	という要素がその醜い頭を上げない程度に、コアシステムの設定と制
	御ファイルを防御することだけです。たとえば、
	<filename>/</filename> および <filename>/usr</filename> にある
	大部分のファイルに <literal>schg</literal> ビットを設定するた
	めに <command>chflags</command> を使用するのは、おそらく逆効果
	でしょう。なぜなら、そうすることでファイルは保護できますが、侵
	入を検出する窓を閉ざしてしまうことにもなるからです。セキュリティ
	のタマネギの最後の層はおそらく最も重要なもの &mdash; 検出で
	す。セキュリティの残りのものは、突然の侵入を検出できなければ、
	まったく有用ではありません (あるいは、もっと悪ければ、安全性に
	対する間違った感覚を植え付けてしまいます)。タマネギの仕事の半
	分は、もう半分の検出側が攻撃者を攻撃の最中に捕えるようにするた
	めに、攻撃者を食い止めるのではなく侵入を遅らせることなのです。
	</para>

      <para>侵入を検出する最も良い方法は、変更されていたり、消えていた
	り、入れた覚えがないのに入っているファイルを探すことです。変更
	されたファイルを探すのに最も良い方法は、もう一つの (しばしば中
	央に集められた)、アクセスが制限されたシステムから行なうもので
	す。さらに安全でアクセス制限されたシステム上でセキュリティ用ス
	クリプトを書けば、
	スクリプトは潜在的な攻撃者からはほぼ見えなくなります。
	これは重要なことです。この有効性を最大限に活用
	するためには、一般的に、アクセスの制限されたマシンから実際に使っている他のマシンへのかなりのアクセスを許可する必要があります。普
	通は、他のマシンからアクセス制限されたマシンへ読み込み専用の
	NFS エクスポートをしたり、アクセス制限されたマシンから他のマシンへ
	ssh 接続を行なうために、
	ssh 鍵のペアを作ったりすることで行います。
	ネットワークのトラフィックを別にして、NFS は最も可視性
	のない方法です &mdash; 各クライアント上のファイルシステムを、
	事実上検出されずに監視できるようになります。アクセス制限された
	サーバがスイッチを通してクライアントに接続されている場合、たい
	てい NFS がより良い選択肢です。アクセス制限されたサーバがハブ
	や、いくつかのルーティング層を通してクライアントに接続している場合、
	NFS は (ネットワークの面で) あまりにも危険なので、
	ssh の方が認証を行った跡は残りますが、良い方法でしょう。</para>

      <para>アクセス制限されたマシンに、監視しようとするクライアントシ
	ステムへの少なくとも読み込みのアクセス権を与えたら、次に実際に
	監視するためのスクリプトを書かなくてはいけません。NFS マウント
	をすれば、&man.find.1; や &man.md5.1; などの単純なシステムユー
	ティリティでスクリプトを書くことができます。少なくとも 1 日 1
	回、クライアントのファイルを直接 md5 にかけ、さらにもっと頻繁
	に <filename>/etc</filename> および
	<filename>/usr/local/etc</filename> にあるようなコントロール用
	ファイルを試験するのが一番です。アクセス制限されたマシンが正し
	いと知っている、基となる md5 情報と比べて違いが見つかった場合、
	システム管理者に調べて欲しいと悲鳴を上げるようにすべきです。優
	れたセキュリティ用スクリプトは、<filename>/</filename> および
	<filename>/usr</filename> などのシステムパーティション上で不適
	当に suid されたバイナリや、新たに作成されたファイルや削除され
	たファイルがないかどうかを調べるでしょう。</para>

      <para>NFS ではなく、ssh を使用する場合は、
	セキュリティ用スクリプトを書くのはずっと難しいことで
	す。スクリプトを動かすためには、クライアントに対してスクリプト
	を <command>scp</command> しなくてはいけませんし、それは目に見
	えてしまいます。そして、安全のためには、スクリプトが使うバイナ
	リ (find など) を <command>scp</command> する必要もあります。
	クライアントマシンの <application>ssh</application>
	クライアントはすでに攻撃されてしまっているかもしれません。
	結局のところ、安全でないリンク上の場合は
	ssh は必要かもしれませんが、ssh
	を扱うのはとても大変なことです。</para>

      <para>優れたセキュリティ用スクリプトは、ユーザやスタッフメンバの
	アクセス設定ファイルの変更もチェックするものです。
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> など &hellip;
	<literal>MD5</literal> チェックの範囲外になってしまうであろう
	ファイル群です。</para>

      <para>ユーザ用のディスク容量が非常に大きい場合は、パーティション
	上の各ファイルを見て回るのに大変な時間がかかるかもしれません。
	この場合は、マウントフラグを設定して、このパーティションに
	suid されたバイナリやデバイスを置けないようにするのが良い考え
	です。<literal>nodev</literal> および <literal>nosuid</literal>
	オプション (&man.mount.8; 参照) が知るべきものでしょう。
	とにかく少なくとも週に 1 度はファイルシステムをスキャンするべきです。
	なぜなら、この層の目的は、侵入が成功したかどうかに関わらず、侵
	入があったことの検出をすることだからです。</para>

      <para>プロセスアカウンティング (&man.accton.8; 参照) は、
	マシンへの侵入を検出するためのメカニズムとして推奨できる、
	比較的オーバヘッドの少ないオペレーティングシステムの機能です。
	侵入を受けた後でも当該ファイルが無傷である場合に、侵入者が
	実際にどのようにしてシステムに侵入したかを追跡するのに特に役立ちます。</para>

      <para>最後に、セキュリティスクリプトはログファイルを処理するよう
	にし、ログファイル自体もできるだけ安全性の高い方法で生成するよ
	うにすべきです &mdash; リモート syslog は極めて有益になり得ま
	す。侵入者は自分の侵入の痕跡を覆い隠そうとしますし、また、ログ
	ファイルはシステム管理者が最初の侵入の時刻と方法を追跡してゆく
	ために極めて重要です。ログファイルを永久に残しておくための 1
	つの方法は、システムコンソールをシリアルポートにつないで走らせ、
	コンソールを監視している安全なマシンを通して絶えず情報を集める
	ことです。</para>
    </sect2>

    <sect2>
      <title>偏執狂的方法</title>

      <para>多少偏執狂的になっても決して悪いことにはなりません。原則的
	に、システム管理者は、便利さに影響を与えない範囲でいくつでもセ
	キュリティ機能を追加することができます。
	また、いくらか考慮した結果、
	便利さに<emphasis>影響を与える</emphasis>セキュリティ機能を追加することもできます。
	より重要なことは、
	セキュリティ管理者はこれを多少混ぜこぜにして使うべきだということです。
	&mdash; もしあなたが、本文書に書かれている勧告をそのまま使用した場合は、
	予想される攻撃者はやはり本文書を読んでいるわけですから、
	あなたの防御策を教えてしまうことになります。</para>
    </sect2>

    <sect2>
      <title>サービス妨害攻撃</title>
      <indexterm><primary>サービス妨害 (DoS)</primary></indexterm>

      <para>このセクションではサービス妨害攻撃 (DoS 攻撃) を扱います。
	サービス妨害攻撃は、普通は、パケット攻撃です。ネットワークを飽
	和させる最先端の偽造パケット (spoofed packet) 攻撃に対してシス
	テム管理者が打てる手はそれほど多くありませんが、一般的に、その
	種の攻撃によってサーバがダウンしないことを確実にすることで、被
	害をある限度に食い止めることはできます。</para>

      <orderedlist>
	<listitem>
	  <para>サーバの fork の制限。</para>
	</listitem>

	<listitem>
	  <para>踏み台攻撃の制限 (ICMP 応答攻撃、ping broadcast など)。
	  </para>
	</listitem>

	<listitem>
	  <para>カーネルの経路情報のキャッシュ。</para>
	</listitem>
      </orderedlist>

      <para>よくあるサービス妨害攻撃は、fork するサーバプロセスに対す
	るものです。これは、サーバにプロセス、ファイル記述子、メモリを
	マシンが死ぬまで食い尽くさせようとするものです。
	<application>inetd</application>
	(&man.inetd.8; 参照) には、この種の攻撃を制限するオプションが
	いくつかあります。マシンがダウンすることを防止することは可能で
	すが、この種の攻撃によりサービスが中断することを防止することは
	一般的に言ってできないことに注意する必要があります。
	<application>inetd</application>
	のマニュアルページを注意深く読んで下さい。特に、
	<option>-c</option>, <option>-C</option>, <option>-R</option>
	オプションに注意して下さい。IP 偽造攻撃 (spoofed-IP attack) は
	<application>inetd</application> の
	<option>-C</option> オプションの裏をかけるので、
	一般にオプションを組み合わせて使用するべきであることに注意して下さ
	い。スタンドアロンサーバの中には、自分自身で fork を制限するパ
	ラメータを持っているものがあります。</para>

      <para><application>Sendmail</application> には、
	<option>-OMaxDaemonChildren</option> オプションがあります。シ
	ステム負荷の値変化には遅れがあるので、sendmail の負荷限界指定
	オプションを使うよりも、このオプションを使う方がまともに動作す
	る可能性ははるかに高いです。
	<application>sendmail</application> の実行を開始する際に、
	<literal>MaxDaemonChildren</literal> パラメータを設定するべき
	です。その値は、通常見込まれる負荷を扱える程度に十分高いが、そ
	れだけの数の <application>sendmail</application> を操作しよう
	とするとマシンが卒倒してしまうほどには高くないような値に設定す
	るべきです。sendmail をキュー処理モード
	(<option>-ODeliveryMode=queued</option>) で実行することや、
	sendmail デーモン (<command>sendmail -bd</command>) をキュー処
	理用プロセス (<command>sendmail -q15m</command>) と別に実行す
	ることも、用心深いことと言えます。それでもなおリアルタイムでの
	配送を望むのであれば、<option>-q1m</option> のようにすることで、
	キュー処理をはるかに短い時間間隔で行うことができます。いずれに
	しても、<literal>MaxDaemonChildren</literal> オプションに合理
	的な値を確実に指定して、sendmail がなだれをうって失敗すること
	がないようにして下さい。</para>

      <para><application>syslogd</application> は直接攻撃される可能性
	があるので、可能ならばいつでも <option>-s</option> オプション
	を用いることを強く推奨します。これができないなら、
	<option>-a</option> オプションを使って下さい。</para>

      <para><application>TCP Wrapper</application> の逆 identd などの接
	続返し (connect-back) を行うサービスについては十分注意を払うよ
	うにするべきです。これらは直接攻撃を受ける可能性があります。こ
	ういう事情があるので、<application>TCP wrapper</application> の
	逆 ident 機能を使おうとは思わないのが一般的です。</para>

      <para>境界ルータのところでファイアウォールを設けて、外部からのア
	クセスに対して内部サービスを防御するという考えは実によいもので
	す。この考えは、LAN の外部からの飽和攻撃を防ぐことにあり、内部
	サービスをネットワークベースの <systemitem class="username">root</systemitem>
	権限への攻撃から防御するこ
	とにはあまり考慮を払っていません。ファイアウォールは常に排他的
	に設定して下さい。つまり、<quote>ポート A, B, C, D と M から Z
	まで<emphasis>以外</emphasis> のすべてにファイアウォールを設ける</quote>
	というふうにです。このようにすることで、
	<application>named</application> (ゾーンのプライマリである場合)、
	<application>ntalkd</application>,
	<application>sendmail</application> などのインターネットからア
	クセスできるサービスとして特に指定するもの以外の、小さい番号の
	ポートすべてをファイアウォールで防御することができます。ファイ
	アウォールをこの他のやり方 &mdash; つまり包含的もしくは受容的
	なファイアウォールとして設定しようとする場合、
	<quote>close</quote> することを忘れてしまうサービスがいくつか
	出てきたり、新しい内部サービスを追加したのにファイアウォールの
	更新を忘れたりする可能性がよく出てきます。ファイアウォール上の
	大きい番号のポートを開けておくことにより、小さい番号のポートを
	危険に晒すことなく受容的な動作を許すことができます。&os; で
	は、<varname>net.inet.ip.portrange</varname> への
	<command>sysctl</command> (<command>sysctl -a | fgrep
	portrange</command>) をいろいろ使用することで、動的バインドに使用される
	ポート番号の範囲を制御できることを記憶にとどめておいてください。
	これによりファイアウォールの設定を簡略化することもできます。
	たとえば、通常の first/last 範囲として 4000 から 5000 を、
	高位ポートの範囲として、49152 から 65535 を指定し、
	(いくつかのインターネットアクセス可能
	なポートをブロックから除外するのはもちろんですが) 4000
	より下のすべてのポートをブロックするという設定が考えられます。</para>

      <indexterm><primary>ICMP_BANDLIM</primary></indexterm>

      <para>また別のよくあるサービス妨害攻撃として、踏み台攻撃
	(springboard attack) と呼ばれるものがあります &mdash; これは、
	あるサーバを攻撃し、そこ結果として生成される応答が自分自身、ロー
	カルネットワーク、そして他のマシンを過負荷に追い込むようにする
	攻撃です。この種の攻撃の中で最もありふれたものに、
	<emphasis>ICMP ping broadcast 攻撃</emphasis>があります。攻撃
	者は、実際に攻撃したいマシンのアドレスを送信元アドレスに設定し
	た ping パケットを偽造して、対象の LAN のブロードキャストアド
	レスに向けてパケットを送信します。境界にあるルータがブロードキャ
	ストアドレスに対する ping パケットを握り潰すように設定されてい
	ない場合、LAN は、詐称された送信元アドレスに向けて応答パケット
	を生成するはめになり、犠牲となるマシンが飽和するところまで行っ
	てしまいます。攻撃者が同じトリックを異なるネットワーク上のいく
	つものブロードキャストアドレスに対して同時に使用した場合、とく
	にひどいことになります。これまでに、120 メガビット以上のブロー
	ドキャスト攻撃が観測されています。2 番目の踏み台攻撃は、ICMP
	エラー報告の仕掛けを狙うものです。攻撃者は ICMP エラー応答を生
	成するパケットを生成し、サーバの受信ネットワークを飽和させ、そ
	の結果としてサーバが送信ネットワークを ICMP 応答で飽和させてし
	まうようにすることができます。mbuf を消費し尽くさせることによ
	り、この種の攻撃でサーバをクラッシュさせることも可能です。サー
	バが生成した ICMP 応答を十分速く送信できない場合、とくにひどい
	ことになります。&os; カーネルには、この種の攻撃の効果を抑制する
	<option>ICMP_BANDLIM</option>
	と呼ばれる新しいカーネルコンパイルオプション
	があります。踏み台攻撃の 3 つめの主要なクラスに属する攻撃は、
	udp echo サービスのような、特定の
	<application>inetd</application> 内部サービスに関連する
	ものです。攻撃者は、単に送信元アドレスがサーバ A の echo ポー
	トであり、送信先アドレスがサーバ B の echo ポートであるように
	UDP パケットを偽造します。ここでサーバ A, B はともにあなたの
	LAN に接続されています。この 2 つのサーバは、この一つのパケッ
	トを両者の間で互いに相手に対して打ち返しあいます。このようにし
	てパケットをほんのいくつか注入するだけで、攻撃者は両方のサーバ
	と LAN を過負荷状態にすることができます。同様の問題が内部
	<application>chargen</application> ポートにも存在します。
	有能なシステム管理者はこの手の
	inetd 内部テストサービスのすべてを無効にしておくものです。
	</para>

      <para>偽造パケット攻撃は、カーネルの経路情報キャッシュに過負荷を
	生じさせるために用いられることもあります。
	<varname>net.inet.ip.rtexpire</varname>,
	<varname>rtminexpire</varname>, <varname>rtmaxcache</varname>
	の <command>sysctl</command> パラメータを参照して下さい。でた
	らめな送信元 IP アドレスを用いた偽造パケット攻撃により、カーネ
	ルは、一時的なキャッシュ経路を経路情報テーブルに生成します。こ
	れは <command>netstat -rna | fgrep W3</command> で見ることがで
	きます。これらの経路は、普通は 1600 秒程度でタイムアウトになり
	ます。カーネルがキャッシュ経路テーブルが大きくなり過ぎたことを
	検知すると、カーネルは動的に <varname>rtexpire</varname>
	を減らしますが、<varname>rtminexpire</varname>
	より小さくなるようには決して減らしません。ここに問題が
	2 つあります。</para>

      <orderedlist>
	<listitem>
	  <para>負荷の軽いサーバが突然攻撃された場合、カーネルが十分素
	    早く反応できないこと。</para>
	</listitem>

	<listitem>
	  <para>カーネルが持続的攻撃に耐えられるほど十分
	    <varname>rtminexpire</varname> が低く設定されていないこと。</para>
	</listitem>
      </orderedlist>

      <para>自分のサーバが T3 もしくはそれより高速の回線でインターネッ
	トに接続されている場合、&man.sysctl.8; を用いて
	<varname>rtexpire</varname> と <varname>rtminexpire</varname>
	とを手動で上書きしておくことが思慮深いことといえます。どちらか
	一方でも 0 には決してしないで下さい (自分のマシンをクラッシュ
	させたくないのであれば)。両パラメータを 2 秒
	に設定すれば、攻撃から経路情報テーブルを守るには十分でしょう。
	</para>
    </sect2>

    <sect2>
      <title>Kerberos および SSH を用いたアクセスの問題</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>もしあなたが、Kerberos と ssh を使いたいのだとしたら、
	両者に関して言っておかねばならない問題がいくつかあります。
	Kerberos V は大変優れた認証プロトコルですが、Kerberos 化された
	<application>telnet</application> や
	<application>rlogin</application> は、バイナリストリームを扱う
	のに不向きになってしまうようなバグがあります。さらに、デフォル
	トでは、Kerberos は <option>-x</option> オプションを使わない限
	りセッションを暗号化してくれません。
	<application>ssh</application> では、デフォルトですべてを暗号
	化してくれます。</para>

      <para>ssh はあらゆる場面でとても良く働いてくれます。
	ただし、デフォルトで暗号鍵を転送してしまうこと
	を除けばです。これはつまり、暗号鍵を持った安全なワークステーショ
	ンがあって、この暗号鍵で残りのシステムとアクセスできるようになっ
	ている場合に、安全でないマシンへ
	ssh 接続を行なうとあなたの暗号鍵を使えてしまうということです。
	実際の鍵そのものが見えてしまうわけではありませんが、
	ssh はあなたが login
	している間、転送用ポートを作ります。攻撃者が安全でないマシンの
	<systemitem class="username">root</systemitem> を破ったら、このポートを使って暗号鍵を取得し、
	この暗号鍵でロックが外れる他のマシンへのアクセスを得てしまいます。
	</para>

      <para>スタッフのログインには、Kerberos を組み合せた
	ssh を使用することを勧めます。
	<application>ssh</application> は、Kerberos 対応機能と一緒
	にコンパイルできます。こうすると、見えてしまうかもしれない
	ssh 鍵をあまりあてにしないで良いようになります。
	また、それと同時に、Kerberos 経由でパスワードを保護することもできます。
	ssh 鍵は、安全なマシンからの自動化されたタスク
	(Kerberos はこの用途には不向きです) のみに使用するべきです。また、
	ssh の設定で鍵転送をしないようにするか、あるいは ssh が
	<filename>authorized_keys</filename> ファイル中に書くことを許
	している <literal>from=IP/DOMAIN</literal> オプションを使用し
	て、特定のマシンからログインしてきたときのみ鍵が有効であるよう
	にすることも勧めます。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="crypt">
    <info><title>DES, MD5 と Crypt</title>
      <authorgroup>
	<author><personname><firstname>Bill</firstname><surname>Swingle</surname></personname><contrib>改訂: </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>crypt</secondary>
    </indexterm>

    <indexterm><primary>crypt</primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para><emphasis>訳: &a.hanai;,
	12 September 1996.</emphasis></para>
    <para><emphasis>訳改訂: &a.jp.hino;,
	12 March 2001.</emphasis></para>

    <para>&unix; システムにおけるすべてのユーザは、そのアカウントに対応し
      た一つのパスワードを持っています。それらのパスワードはユーザ本人
      と本当のオペレーティングシステムのみが知っているべきであるという
      ことは明らかでしょう。それらのパスワードを秘密に保っておくために、
      パスワードは<quote>一方向ハッシュ</quote>として知られる方式で暗
      号化されます。一方向ハッシュとは、簡単に暗号化はできるが解読は難
      しいという方法です。言葉を換えると、先ほど明らかであると書いたの
      は実は正しくないのです: オペレーティングシステム自身は<emphasis>
      本当は</emphasis>パスワードを知らないのです。その代わりに
      <emphasis>暗号化された</emphasis>形でのみパスワードを知っていま
      す。<quote>素のテキスト</quote>としてパスワードを得る唯一の方法は、
      可能な限りのパスワード空間を検索するという力任せの方法です。
      </para>

    <para>不幸なことに、&unix; が生まれようとしているときにパスワードを
      安全な形で暗号化できる方式は DES (Data Encryption Standard)
      に基づいたものだけでした。このことは米国に住んでいるユーザにとって
      は大して問題ではありませんでしたが、DES のソースコードを米国外に
      輸出することはできないという問題がありました。そのために、
      &os; は、米国の法律を守ることと、未だに DES を使っていた他の
      &unix; 一族との互換性を保つこととを両立する方法を探し出す必要がありました。</para>

    <para>その解決方法は、米国のユーザは DES のライブラリをインストー
      ルして DES を使用できるが、米国外のユーザは国外に輸出可能な他の
      ひとつの暗号化方式を使用することができる、というように暗号化ライ
      ブラリを分割することでした。これが &os; がデフォルトの暗号化
      方式として MD5 を使うようになったいきさつです。MD5 は DES よりも
      より安全であると考えられているため、DES をインストールする一番の
      理由は互換性を保つためといえます。</para>

    <sect2>
      <title>暗号化機構を理解する</title>

      <para>&os;&nbsp;4.4 の前までは、<filename>libcrypt.a</filename>
	は暗号化に使われるライブラリへのシンボリックリンクでした。
	&os;&nbsp;4.4 で <filename>libcrypt.a</filename>
	は設定可能なパスワード認証ハッシュライブラリを提供するようになりました。
	現在のところ、このライブラリは DES, MD5 および Blowfish
	ハッシュ関数に対応しています。デフォルトでは、&os;
	はパスワードの暗号化に MD5 を利用します。</para>

      <para>&os; がどの暗号化方式を使うようにセットアップされている
	かを判断するのは簡単です。
	<filename>/etc/master.passwd</filename> ファイルの中の暗号化さ
	れたパスワードを調べてみるのが一つの方法です。MD5 ハッシュで暗
	号化されたパスワードは、DES ハッシュで暗号化されたパスワードよ
	りも長く、<literal>&dollar;1&dollar;</literal>
	という文字で始まるという特徴を持っています。
	<literal>&dollar;2a&dollar;</literal>
	で始まるパスワードは、Blowfish ハッシュ関数で暗号化されています。
	DES のパスワードはこ
	れといって識別可能な特徴は持っていませんが、MD5 のパスワードよ
	りは短く、そして <literal>&dollar;</literal> という文字を含ま
	ない 64 文字のアルファベットを使って表現されているので、比較的
	短い文字列でドル記号で始まっていないものはおそらく DES のパス
	ワードでしょう。</para>

      <para>新規パスワードがどちらのパスワード形式になるかは、
	<filename>/etc/login.conf</filename> の中の
	<literal>passwd_format</literal>
	ログインケーパビリティによって制御されます。
	その値としては、<literal>des</literal>,	<literal>md5</literal>
	または <literal>blf</literal> を設定することができます。
	ログインケーパビリティに関するより詳細な情報は、
	&man.login.conf.5; マニュアルページをご覧ください。</para>

    </sect2>
  </sect1>

  <sect1 xml:id="one-time-passwords">
    <title>ワンタイムパスワード</title>
    <indexterm><primary>ワンタイムパスワード</primary></indexterm>
    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>ワンタイムパスワード</secondary>
    </indexterm>

    <para>S/Key は一方向ハッシュ関数を基にしたワンタイムパスワード方式
      です。&os; では、互換性のために MD4 ハッシュを用いていますが
      他のシステムでは MD5 や DES-MAC を用いてます。S/Key は、バージョ
      ン1.1.5 以降のすべての &os; に含まれていますし、&os; 以外
      の数多くのシステムの上でも利用されています。S/Key は Bell
      Communications Research, Inc. の登録商標です。</para>

    <para>&os; バージョン 5.0 以降では、S/Key
      は機能的に同等な OPIE (One-time Passwords In Everything)
      で置き換えられました。OPIE はデフォルトでは
      MD5 ハッシュを使用します。</para>

    <para>ここでは、三種類の異なる「パスワード」について説明します。
      まず一つ目は、あなたが普段使っている普通の
      &unix; スタイルの、もしくは Kerberos
      のパスワードです。ここではこれを
      <quote>&unix; パスワード</quote> と呼ぶことにします。二つ目は、S/Key
      の <command>key</command> プログラム、または
      OPIE の &man.opiekey.1; プログラムによって生成され、
      <command>keyinit</command> または &man.opiepasswd.1;
      プログラムとログインプロンプトが受け付けるパスワードです。
      ここではこれを <quote>ワンタイムパスワード</quote>
      と呼ぶことにします。三つ目のパスワードは、
      <command>key</command>/<command>opiekey</command> (と場合により
      <command>keyinit</command>/<command>opiepasswd</command>)
      プログラムに対してユーザが入力する秘密のパスワードで、
      ワンタイムパスワードを生成するのに使われます。ここではこれを
      <quote>秘密のパスフレーズ</quote> もしくは単に
      <quote>パスフレーズ</quote> と呼ぶことにします。
      (訳注: ユーザが頭の中だけにしまっておくべきものが、
      この秘密のパスフレーズです。なお、原文ではこれを
      <quote>password</quote> と表記していますが、
      混乱を避けるために訳文ではすべて
      <quote>秘密のパスフレーズ</quote> に統一しています)。</para>

    <para>秘密のパスフレーズは、&unix;
      パスワードと何の関連性もありません。
      両者を同一に設定することは可能ですが、お奨めしません。古い &unix;
      パスワードは長さが 8 文字に制限されていました
      <footnote><para>&os; では、標準のログインパスワードは、128
      文字までとなります。</para></footnote>。
      これに対し、S/Key や OPIE
      では秘密のパスフレーズを好きなだけ長くすることができます
      (訳注: 実装上、<command>key</command> コマンドなどの
      バッファ長で制限されてしまう可能性があります。200 文字程度に押
      えておいた方がよいでしょう :-)。
      6 語から 7 語からなるパスフレーズがふつうです。ほとんどの部分で、
      S/Key や OPIE システムは Unix
      のパスワードシステムと完全に独立して動作するようになっています。</para>

    <para>パスフレーズに加え、S/Key や OPIE
      システムにとって重要な 2 種類のデータがあります。一つは
      <quote>シード (seed: 種)</quote> または
      <quote>キー (key: 鍵)</quote> と呼ばれるもので、2 つの文字と
      5 つの数字で構成されます。もう一つは <quote>シーケンス番号 (iteration
      count)</quote> で、1 から 100 までの整数です。S/Key はここまで
      に述べたデータを利用してワンタイムパスワードを生成します。その方
      法は、まずシードと秘密のパスフレーズを連結し、それに対してシーケ
      ンス番号の回数だけ MD4/MD5 ハッシュを繰り返し計算します。
      そしてその結果を 6 つの短い英単語に変換します。
      認証システム (一次的には PAM)
      は、前回最後に受け付けたワンタイムパスワードを記録しています。
      そして、その前回
      のワンタイムパスワードと、ユーザが入力したワンタイムパスワードを
      1 回ハッシュ関数にかけた結果とが一致した場合に、このユーザは認証
      されます。一方向ハッシュ関数を使っているので、もし正しく認証され
      たワンタイムパスワードが一回盗聴されたとしても、次回以降に使われ
      る複数のワンタイムパスワードを生成することは不可能です。シーケ
      ンス番号はログインが成功するたびに一つずつ減らされて、ユーザとロ
      グインプログラムの間で同期が取られます。シーケンス番号が 1 まで
      減ったら、S/Key や OPIE を再度初期化する必要があります。</para>

    <para>次に、それぞれのシステムで関連する
      3 つのプログラムについて説明します。
      <command>key</command> と <command>opiekey</command>
      プログラムは、シーケンス番号と、シードと、
      秘密のパスフレーズを受け付けて、ワンタイムパスワード 1 つ、
      または一連のワンタイムパスワードの一覧を生成します。
      <command>keyinit</command> と <command>opiepasswd</command>
      プログラムは、それぞれ S/Key と OPIE
      を初期化するのに使用され、また秘密のパスフレーズ、
      シーケンス番号やシードを変更するためにも使用されます。
      それぞれのプログラムを実行するには、秘密のパスフレーズか、
      または、シーケンス番号とシードとワンタイムパスワードの
      1 組かの、どちらかを与えます。
      <command>keyinfo</command> と <command>opieinfo</command> プログラムは、
      それぞれに対応する認証ファイル (<filename>/etc/skeykeys</filename>
      または <filename>/etc/opiekeys</filename>)
      を調べて、プログラムを起動したユーザの現在のシーケンス番号とシードを表示します。</para>

    <para>この文書では、4 種類の異なる操作について説明します。
      1 つ目は、<command>keyinit</command> または
      <command>opiepasswd</command> を信頼できる通信路上で利用して、
      最初にワンタイムパスワードを設定したり、
      秘密のパスフレーズやシードを変更する操作です。
      2 つ目は、同じことを行うために <command>keyinit</command>
      または <command>opiepasswd</command>
      を信頼できない通信路上で利用する操作です。
      この場合は信頼できる通信路経由の
      <command>key</command> または <command>opiekey</command>
      を併用します。3 つ目は、<command>key</command> または
      <command>opiekey</command>
      を使い、信頼できない通信路を通じてログインする操作です。
      4 番目は、<command>key</command> または <command>opiekey</command>
      を使って複数のワンタイムパスワードを一気に生成する操作です。
      ここで生成した複数のワンタイムパスワードは、
      メモしたり印刷したりして携帯し、
      信頼できる通信路が一切ないところで利用することができます。
      (訳注: ワンタイムパスワードを記録した紙をなくさないこと!
       電話番号や
       IP アドレス、ユーザ名を一緒にメモしていたら最悪です!!)</para>

    <sect2>
      <title>信頼できる通信路での初期化</title>

      <para>信頼できる通信路 (たとえばあるマシンのコンソール画面や、
	<application>ssh</application>
	を使っている時など) を利用しているときに、S/Key を初めて初期化
	すること、S/Key の秘密のパスフレーズを変更すること、またはシー
	ドを変更すること、をおこなうことができます。そのためには、まず
	あなた自身がログインし、<command>keyinit</command> コマンドを
	以下のようにパラメータなしで実行します。</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
        ) `keyinit' コマンドが出力する注意です。訳すと、
        ) 注意 - この動作モードはマシンに直接入力しているときのみ利用
        ) すること。もし今 telnet や rlogin を使っているなら、秘密のパ
        ) スフレーズを入力せずにこのままコマンドを終了し、かわりに
        ) keyinit -s を実行すること。
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para>OPIE では <command>opiepasswd</command>
	が代わりに使われます。</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
        ) `opiepasswd' コマンドが出力する注意です。訳すと、
        ) この手順はコンソール以外では利用しないでください。リモートからは
        ) 絶対に利用してはいけません。telnet, xterm またはダイアルアップで
        ) 利用している場合は、^C を入力するかパスワードを入れずに終了してく
        ) ださい。その後、opiepasswd を -c オプションなしで実行してください。
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para><prompt>Enter new secret pass phrase:</prompt>
	または <prompt>Enter secret password:</prompt>
	というプロンプトに対して、
	あなたが考えた秘密のパスフレーズを入力します。このパスフ
	レーズはログインするときに使うものではなく、ログインするときに
	使うワンタイムパスワードを生成するために使うものであることを覚
	えておいてください。<quote>ID</quote> から始まる行は、
	1 回分のパラメータで、
	あなたのログイン名とシーケンス番号とシードです。
	(訳注: <command>keyinit</command> コマンドは
	次回にログインするときに使えるパラメータを参考のためにここで表示します)。
	システムにログインするときには、
	システム側が自動的にこれらのパラメータを表示してくれますから、
	これらのパラメータを
	覚えておく必要はありません。最後の行が、今述べたパラメータと入力
	された秘密のパスフレーズから計算されたワンタイムパスワードです。
	この例を実行した後、次にログインするときに打ち込むべきワンタイ
	ムパスワードがこれです。</para>
    </sect2>

    <sect2>
      <title>信頼できない通信路での初期化</title>

      <para>信頼できない通信路を使って秘密のパスフレーズを初期化または変更するためには、
	それとは別に <command>key</command> または <command>opiekey</command>
	プログラムを実行するための信頼できる通信路を用意しておく必要があります。
	たとえばそれは、あなたが信頼できる &macintosh;
	のデスクアクセサリや信頼できるマシンのシェルプロンプトだったり
	するでしょう。(訳注: ここでの通信路とはマシンそのものになりま
	す。信頼できるマシンとは、信頼できる人がしっかり管理しているマ
	シンということです)。他に準備しておくものとして、シーケンス番
	号 (100 は適切な値といえるでしょう) と、場合によっては自分で考
	えた、またはランダムに生成されたシードがあります。(あなたが
	S/Key を初期化しようとしているマシンへの) 信頼できない通信路を
	使うときには、<command>keyinit -s</command> コマンドを以下のよ
	うに使用します。</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
	) `keyinit' コマンドが出力する注意です。訳すと、
	) 注意 - skey コマンドの出力する 6 英単語が必要になります。
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
</screen>

      <para>OPIE では、<command>opiepasswd</command>
	を使います。</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
	) `opiepasswd' コマンドが出力する注意です。訳すと、
	) OTP 生成器の返す出力が必要になります。
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>デフォルトのシード (<command>keyinit</command> プログラム
	は困ったことにこれを <literal>key</literal>
	と呼んでいるのですが、混乱しないよう注意してください)
	で構わなければ、<keycap>Return</keycap>
	を押してください。次に、アクセスパスワードを入れる前に、あらか
	じめ用意しておいた信頼できる通信路(信頼できるマシンや信頼でき
	る S/Key デスクアクセサリなど) へ移って、先ほどと同じパラメータ
	を入力します。</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;秘密のパスフレーズ&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>OPIE では、</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>ここで信頼できない通信路の方に戻って、
	生成されたワンタイムパスワードをコピーして対応するプログラムに入力します。</para>
    </sect2>

    <sect2>
      <title>ワンタイムパスワードを一つ生成する</title>

      <para>S/Key または OPIE を初期化したら、
	ログイン時には以下のようなプロンプトが出てくるでしょう。</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;ユーザ名&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>OPIE については、</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>ここでは表示していませんが、S/Key と OPIE
	のプロンプトには便利な機能が備わっています。
	パスワードプロンプトに対して、何も入力せずに
	<keycap>Return</keycap> を押すとエコーモードに切り替わります。
	つまりタイプした文字がそのまま見えるようになるのです。
	これは、紙に印刷していたりするワンタイムパスワードを
	手で入力しなければならない場合に特に役立つ機能です。</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>次に、
	このログインプロンプトに対して入力するワンタイムパスワードを生成しなければなりません。
	これは、<command>key</command> または <command>opiekey</command>
	プログラムを使える信頼できるマシン上で行わなければなりません。
	(これらのプログラムには DOS や &windows;, &macos; 版があります)。
	どちらも、コマンドラインからシーケンス番号とシードを指定しなければなりません。
	ログインしようとしているマシンのログインプロンプトから直接カットアンドペーストすると楽でしょう。</para>

      <para>信頼できるシステムで</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>OPIE では</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>ここでワンタイムパスワードが得られました。
	ログインを続けましょう。</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</screen>

    </sect2>

    <sect2>
      <title>複数のワンタイムパスワードを生成する</title>

      <para>都合によっては、
	信頼できるマシンや信頼できる通信路が一切確保できないようなところで
	S/Key を使う必要があるでしょう。
	このような場合には、<command>key</command> および
	<command>opiekey</command>
	コマンドを使って複数のワンタイムパスワードをあらかじめ一気に生成し、
	紙に印刷して携帯していくことができます。たとえば</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;秘密のパスフレーズ&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para>OPIE の場合には以下のようになります。</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para><option>-n 5</option> という引数によって 5 個のワンタイム
	パスワードを順に生成します。ここで <option>30</option> は、最
	後のシーケンス番号となるべき数字です。出力は普通に使う順番とは
	<emphasis>逆</emphasis>に出力されていることに注意してください
	(訳注: 一番最初に使うワンタイムパスワードは一番最後に出力され
	たものです)。この結果をカットアンドペーストして
	<command>lpr</command> コマンドを使って印刷すると よいでしょう。
	もしあなたがセキュリティに偏執するなら、この結果を紙と鉛筆を使っ
	て手で書き移した方がよいかもしれません。ここで、出力の各行はシー
	ケンス番号とそれに対応する一回分のワンタイムパスワードです。
	消費済みの ワンタイムパスワードの行をペンで消していくと便利で
	しょう。</para>
    </sect2>

    <sect2>
      <title>&unix; パスワードの利用を制限する</title>

      <para>S/Key は、ログインを受け付ける際のホスト名、ユーザ名、
	端末のポート、IP アドレスなどを利用して、
	&unix; パスワードの利用を制限することができます。
	設定ファイル <filename>/etc/skey.access</filename> に、
	制限が記載されています。
	この設定ファイルの詳細に関してはマニュアル &man.skey.access.5;
	をご覧ください。
	マニュアルにはこの機能に関わるセキュリティについて、
	いくつかの警告が記述してあります。
	この機能を使ってセキュリティを高めようとするのならば、
	絶対にこのマニュアルを読んでください。</para>

      <para>もし <filename>/etc/skey.access</filename>
	ファイルが存在しないならば (&os; 4.X
	のデフォルト状態ではそうです)、すべてのユーザが &unix;
	パスワードを利用することができます。
	逆に、もしファイルが存在するならば、
	<filename>skey.access</filename>
	ファイルに明示的に記述されていない限り、すべてのユーザは S/Key
	の利用を要求されます。どちらの場合においても、
	そのマシンのコンソールからはいつでも &unix;
	パスワードを使ってログインすることが可能です。</para>

      <para>以下によく使われるであろう三種類の設定を含む設定ファイル
	<filename>skey.access</filename> の例を示します。</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>はじめの行 (<literal>permit internet</literal>) で、telnet
	などで接続するときの IP のソースアドレス (注意: これは偽造され
	るおそれがあります) が特定の値とマスクに一致している場合に、
	&unix; パスワードの利用を許可することを指定しています。
	この設定自体はセキュリティを高めるための機能ではありません。そうでは
	なく、ログインの権利を持つ許可されたユーザに対して、現在そのユー
	ザが使っているネットワークが信頼できないと考えられるので S/Key
	を使うべきである、ということを気づかせるための機能であると考え
	てください。</para>

      <para>二行目 (<literal>permit user</literal>)
	によって、ある特定のユーザ、この場合は
	<systemitem class="username">fnord</systemitem>、に対して、
	いつでも &unix;
	パスワードの利用を許可するように指定しています。
	一般的にはこの設定をおこなうべきではありません。
	<command>key</command> プログラムがどうしても使えない環境にい
	る人や、ダム端末しかない環境にいる人、または何度教えても聞く耳
	を持たないような人をサポートする必要がある場合にのみ設定をおこ
	なってください。</para>

      <para>三行目 (<literal>permit port</literal>) によって、ある特定
	の端末ポートからログインしようとするすべてのユーザに対して
	&unix; パスワードの利用を許可するように指定しています。この設定
	はダイヤルアップ回線に対する設定として利用できるでしょう。</para>

      <para>OPIE は S/Key が行うような、ログインセッションの IP
	アドレスをベースとした &unix; パスワードの使用を制限できます。
	関連ファイルは、<filename>/etc/opieaccess</filename> です。
	&os; 5.0 以降のシステムではデオフォルトで用意されています。
	このファイルの詳細や、
	このファイルを使用する際に考慮すべきセキュリィについては
	&man.opieaccess.5; を確認してください。</para>
	
      <para>以下は <filename>opieaccess</filename> ファイルの例です。</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>この行では、(なりすましされやすい) IP ソースアドレスが、
	ある値やマスクにマッチするユーザに対して、
	&unix; パスワードをいつでも許可します。</para>
	
      <para>もし <filename>opieaccess</filename>
	のどのルールにも一致しなければ、
	デフォルトでは非 OPIE ログインは使えません。</para>

    </sect2>
  </sect1>

  <sect1 xml:id="tcpwrappers">
    <info><title>TCP Wrappers</title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>執筆: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>TCP Wrappers</primary></indexterm>

    <para>&man.inetd.8; に詳しい方であれば、
      <acronym>TCP</acronym> Wrappers について聞いたことがあるでしょう。
      しかし、
      その有効性をネットワーク環境において完全に理解している人はほとんどいなく、
      誰もがネットワーク接続を取り扱うために、
      ファイアウォールをインストールしたいと考えているようです。
      ファイアウォールは、幅広い用途がある一方で、
      接続元に対しテキストを送るといった、取り扱ない作業があります。
      <acronym>TCP</acronym> ソフトウェアは、これ以上のことができます。
      以下の節では、
      <acronym>TCP</acronym> Wrappers の多くの機能が説明されています。
      そして、適応できる場合には、設定行の例が紹介されています。</para>

    <para><acronym>TCP</acronym> Wrappers ソフトウェアは、
      <command>inetd</command>
      の管理のもとにすべてのサーバデーモンに対応する機能を拡張します。
      この方法を使うことで、ログへの対応、
      接続に対してメッセージを返したり、
      内部の接続だけを許可するようにデーモンを設定することなどが可能となります。
      これらの機能のいくつかはファイアウォールでも実装できますが、
      保護のための特別なレイヤを追加するだけでなく、
      ファイアウォールが提供する以上の管理を提供します。</para>

    <para><acronym>TCP</acronym> Wrappers 機能の追加は、
      ファイアウォールのより良い置き換えと考えるべきではありません。
      <acronym>TCP</acronym> Wrappers は、
      ファイアウォールおよび他のセキュリティ設定と組み合わせて使うことができ、
      システムを守るための追加のレイヤとして上手く機能します。</para>

    <para>この設定は <command>inetd</command> の設定の拡張なので、
      <link linkend="network-inetd">inetd の設定</link>
      章をすでに読んでいることを想定しています。</para>

    <note>
      <para>&man.inetd.8; により起動されるプログラムは、正確には、
	<quote>デーモン</quote> ではありませんが、
	伝統的にデーモンと呼ばれています。
	この章でも、このように呼ぶこととします。</para>
    </note>

    <sect2>
      <title>初期設定</title>

      <para>&os; 上で <acronym>TCP</acronym> Wrappers
	を使用ために必要となるのは、
	<filename>rc.conf</filename> から
	<option>-Ww</option> オプションで
	<command>inetd</command> サーバが起動されることを確認するだけです。
	これはデフォルトの設定です。
	もちろん、
	<filename>/etc/hosts.allow</filename>
	も適切に設定されていることが前提です。
	この場合、&man.syslogd.8;
	はシステムログにメッセージを出力します。</para>

      <note>
	<para>他の <acronym>TCP</acronym> Wrappers の実装と異なり、
	  <filename>hosts.deny</filename> は廃止されました。
	  すべての設定オプションは <filename>/etc/hosts.allow</filename>
	  に書かれている必要があります。</para>
      </note>

      <para>最も簡単な設定におけるデーモンの接続ポリシは、
	<filename>/etc/hosts.allow</filename> の中で、
	オプションごとに許可またはブロックするように設定するというものです。
	&os; のデフォルトの設定では、<command>inetd</command>
	から起動されたすべてのデーモンの接続を許可します。
	この設定を変更することについては、
	基本的な設定を理解した後で議論されるべきです。</para>

      <para>基本的な設定は、通常
	<literal>daemon : address : action</literal>
	という形式です。ここで、
	<literal>daemon</literal> は、
	<command>inetd</command> が起動するデーモンの名前です。
	<literal>address</literal> の部分は、有効なホスト名、
	<acronym>IP</acronym> アドレスまたは、
	括弧 ([&nbsp;]) で囲まれた IPv6 アドレスです。
	action フィールドの部分は、アクセスを適切に許可または拒否をするように、
	allow または deny となります。
	最初のマッチしたルールが適用されると、
	設定はそこで終わることを覚えておいてください。
	これは、設定ファイルは昇順にルールのマッチをスキャンされ、
	マッチすると、ルールが適用され、
	検索のプロセスは停止することを意味しています。</para>

      <para>他にもいくつかのオプションが存在し、以降の節で説明されます。
	簡単な設定の行は、上記の情報のみで簡単に構成されます。
	例として、<acronym>POP</acronym>3 の接続を、
	<filename role="package">mail/qpopper</filename>
	デーモンから許可するには、以下の行を
	<filename>hosts.allow</filename> に追加してください。</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>この行を追加したら、<command>inetd</command> を再起動してください。
	これを行うには、&man.kill.1; コマンドを使うか、
	<parameter>restart</parameter> パラメータとともに、
	<filename>/etc/rc.d/inetd</filename> を使ってください。</para>
      </sect2>

      <sect2>
        <title>高度な設定</title>

      <para><acronym>TCP</acronym> Wrappers で高度な設定もできます。
	接続を取り扱う以上の制御を行うことができるのです。
	ある時は、接続しているホストまたはデーモンにコメントを返すことが良い考えのことがあります。
	別の場合では、おそらくログファイルを記録したり、
	管理者にメールで送る必要があることもあるでしょう。
	またその他の状況としては、
	サービスをローカルの接続のみで使用できる必要がある場合もあります。
	これらはすべて、<literal>ワイルドカード</literal>
	と呼ばれる設定のオプション (拡張文字および外部コマンドの実行)
	で可能となります。
	以下の 2 つの節では、
	このような状況への対応について触れています。</para>
	
      <sect3>
	<title>外部コマンド</title>

	<para>接続は拒否しなければならないが、
	  その理由を接続の確立を試みた相手に送りたい状況を考えてください。
	  これは、どのように行うことができるでしょうか？
	  このアクションは、<option>twist</option>
	  オプションを使うことで実現可能です。
	  接続が試みられると、<option>twist</option>
	  はシェルコマンドまたはスクリプトの実行を要求します。
	  この場合の例は、
	  <filename>hosts.allow</filename> ファイルに書かれています。</para>

	<programlisting># The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>この例は、
	  <quote>You are not allowed to use <literal>daemon</literal>
	  from <literal>hostname</literal>.</quote> というメッセージを、
	  アクセスファイルの中で設定されていないすべてのデーモンに対して返します。
	  接続元に対し、確立された接続が破棄された直後に返答することは、
	  非常に有効です。
	  返信に使われるメッセージは、<literal>"</literal> 文字で囲む
	  <emphasis>必要</emphasis> があります。
	  この規則に例外はありません。</para>

	<warning>
	  <para>攻撃者や攻撃者のグループは、
	    これらのデーモンの接続のリクエストであふれさせることにより、
	    サーバに対して DoS 攻撃を仕掛けることができます。</para>
	</warning>

	<para>このような状況において、他の可能性は <option>spawn</option>
	  オプションを使うことです。
	  <option>twist</option> と同様に、
	  <option>spawn</option> は、暗黙のうちに接続を拒否し、
	  外部のシェルコマンドやスクリプトを実行できます。
	  <option>twist</option> と異なり、<option>spawn</option> は、
	  接続を確立した相手に対し、返事を返すことはありません。
	  たとえば、以下のような設定の行を考えてみてください。</para>

	<programlisting># We do not allow connections from example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>この行は、
	  <systemitem class="fqdomainname">*.example.com</systemitem>
	  ドメインからの接続をすべて拒否します。
	  同時にホスト名、<acronym>IP</acronym>
	  アドレスおよびアクセスを試みたデーモンが、
	  <filename>/var/log/connections.log</filename>
	  ファイルに記録されます。</para>

	<para>すでに説明した置換文字 (たとえば %a) 以外にも置換文字があります。
	  完全な一覧は
	  &man.hosts.access.5; マニュアルページをご覧ください。</para>
      </sect3>

      <sect3>
	<title>ワイルドカードオプション</title>

	<para>これまでの例においては、継続して
	  <literal>ALL</literal> を使用する例が用いられてきました。
	  この機能を拡張する他のオプションも存在します。たとえば、
	  <literal>ALL</literal> は、
	  デーモン、ドメインまたは <acronym>IP</acronym>
	  アドレスのすべてのインスタンスのどれかにマッチするかどうかに使われます。
	  他のワイルドカードは、偽造された <acronym>IP</acronym>
	  アドレスを提供するホストにマッチするかどうかに用いられる
	  <literal>PARANOID</literal> です。
	  言い換えると、<literal>paranoid</literal> を使うことで、
	  ホスト名と異なる <acronym>IP</acronym>
	  アドレスからの接続があった時のアクションを定義できます。
	  以下の例は、これらの説明を明確にするでしょう。</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>この例では、ホスト名から検索される
	  <acronym>IP</acronym> アドレスと異なる
	  <acronym>IP</acronym> アドレスを持つ
	  <command>sendmail</command>
	  への接続のすべてのリクエストを拒否します。</para>

	<caution>
	  <para>クライアントもしくはサーバの <acronym>DNS</acronym>
	    の設定が間違っている場合に、
	    <literal>PARANOID</literal> を使うと、
	    サーバがとても使いづらくなります。
	    管理者の慎重さが求められます。</para>
	</caution>

	<para>ワイルドカードおよび関連する機能についてもっと知りたい場合には、
	  &man.hosts.access.5; マニュアルページをご覧ください。</para>

	<para>上記の設定が動作するには、<filename>hosts.allow</filename>
	  の中で、最初の設定の行がコメントアウトされている必要があります。
	  これはすでにこの章の最初で説明した通りです。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberosIV">
    <info><title><application>KerberosIV</application></title>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Murray</surname></personname><contrib>寄稿: </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Mark</firstname><surname>Dapoz</surname></personname><contrib>基にした文書の執筆: </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm><primary>Kerberos</primary></indexterm>

    <para><emphasis>訳: &a.jp.arimura;.</emphasis></para>

    <para>Kerberosは、
      サーバのサービスによってユーザが安全に認証を受けられる
      ようにするための、ネットワークの付加システム及びプロトコルです。
      リモートログイン、リモートコピー、
      システム間での安全なファイルのコピ
      ーやその他のリスクの高い仕事がかなり安全に、
      そしてこれまでより制御 できるようになります。</para>

    <para>以下の文章は、
      &os; 用として配布されている Kerberos をセットアップ
      する際のガイドとして読むことができます。しかし、
      完全な説明が必要な場合には、マニュアルページを読んだ方がよい
      でしょう。</para>

    <sect2>
      <title><application>KerberosIV</application> のインストール</title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>インストール</secondary>
      </indexterm>
      <para>Kerberos は選択が任意な &os; のコンポーネントです。
	もっとも簡単なインストール方法は、&os;
	のインストール時に <application>sysinstall</application>
	で <literal>krb4</literal> または <literal>krb5</literal>
	配布物を選択することです。
	そうすると、Kerberos の <quote>eBones</quote> (KerberosIV) または
	<quote>Heimdal</quote> (Kerberos5) 実装がインストールされます。
	これらの実装が入っているのは、
	これがアメリカ合衆国およびカナダの外で開発されたものであるため、
	アメリカ合衆国からの暗号ソフトウェアの輸出が制限されていた時代でも
	アメリカ合衆国およびカナダ以外の国に住んでいるシステム所有者の手に入るものだったからです。</para>

      <para>ほかに、MIT で実装された Kerberos が Ports Collection
	の <package>security/krb5</package>
	から利用できます。</para>
    </sect2>

    <sect2>
      <title>初期データベースの作成</title>

      <para>この作業はKerberosサーバだけでおこないます。まず、
	古いKerberosの データベースが存在しないことを確認してください。
	ディレクトリ<filename>/etc/kerberosIV</filename>に移って、
	次のファイルだけが 存在することをチェックします。</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README          krb.conf        krb.realms</screen>

      <para>もし他のファイル (<filename>principal.*</filename> や
	<filename>master_key</filename>) が 存在する場合には、
	<command>kdb_destroy</command>というコマンドで古い
	Kerberosデータベースを消してください。
	Kerberosが走っていなければ、
	単に余計なファイルを消せばよいです。</para>

      <para>まず、<filename>krb.conf</filename> と
	<filename>krb.realms</filename>を編集してKerberosの 管理領域
	(realm) を定義してください。
	ここでは管理領域が <literal>EXAMPLE.COM</literal>
	で、サーバ名が <systemitem class="fqdomainname">grunt.example.com</systemitem>
	であるとします。
	<filename>krb.conf</filename>
	というファイルを次のように編集してください。</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>この例にあるような他の管理領域は、実際には必要ありません。
	この例は複数の管理領域を認識する方法を示したものですので、
	これらの行は含めなくても結構です。</para>

      <para>1行目はこのシステムが動いている管理領域の名前です。
	他の行は管理領域とホスト名のエントリです。
	行の1つめの単語が管理領域で、2つめがその管理領域の中で
	<quote>鍵配布センター</quote>(Key Distribution Center)
	として働くホスト名です。ホスト名の次に <literal>admin
	server</literal> と書いてある場合には、そのホストが
	管理データベースサーバ (Administrative Database Server)
	も提供することを意味します。
	これらの単語について詳しく知りたい場合には Kerberos
	のマニュアルページをご覧ください。</para>

      <para>ここで、<literal>EXAMPLE.COM</literal> という管理領域に
	<systemitem class="fqdomainname">grunt.example.com</systemitem>
	およびその他の <systemitem class="fqdomainname">.example.com</systemitem>
	ドメインのすべてのホストを追加しなければなりません。
	<filename>krb.realms</filename> は次のようになります。</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>もう一度注意しますが、他の管理領域を書く必要はありません。
	これらは複数の管理領域を認識できるようにマシンを設定する方法を
	示した例ですので、これらの行は消して構いません。</para>

      <para>1行目は名前をつけた管理領域に <emphasis>特定の</emphasis>
	システムを含めるための ものです。
	残りの行は名前をつけた管理領域にサブドメインのデフォルトの
	システムを含めるためのものです。</para>

      <para>これでデータベースを作成する準備ができました。
	この操作はKerberos サーバ (鍵配布センター) を起動するだけです。
	<command>kdb_init</command>コ
	マンドを次のように実行してください。</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Enter Kerberos master key:</prompt> </screen>

      <para>ここで鍵を保存して、
	ローカルのマシンにあるサーバが取り出せるように します。
	それには<command>kstash</command>コマンドを使用します。</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>これで暗号化されたマスタパスワードが
	<filename>/etc/kerberosIV/master_key</filename>
	に保存されました。</para>
    </sect2>

    <sect2>
      <title>すべてが動くようにするための設定</title>

      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>初期設定</secondary>
      </indexterm>

      <para>Kerberosを導入する <emphasis>それぞれの</emphasis>
	システムのデータベースに、2つ のprincipal (主体名)
	を追加する必要があります。その名前は
	<literal>kpasswd</literal>と<literal>rcmd</literal>です。
	これら2つのprincipalは、個々 のシステムにおいて、
	システム名と同じ名前のインスタンスと組にして作成
	されます。</para>

      <para>これらの <application>>kpasswd</application> と
	<application>rcmd</application> というデーモンによって、他の
	システムからKerberosのパスワードを変更したり、
	&man.rcp.1; や &man.rlogin.1;,
	&man.rsh.1; といったコマンドを実行したりできるようになります。</para>

      <para>それでは実際にこれらのエントリを追加しましょう。</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- ここは「RANDOM」と入力してください

<prompt>Random password [y] ? </prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>
    </sect2>

    <sect2>
      <title>サーバファイルの作成</title>

      <para>次に、各マシンにおけるサービスを定義している、
	すべてのインスタンスを展開します。
	これには <command>ext_srvtab</command> というコマンドを使用します。
	このコマンドで作成されるファイルは、Kerberos
	の各クライアントの <filename>/etc/kerberosIV</filename>
	ディレクトリに<emphasis>安全な方法で</emphasis>
	コピーまたは移動する必要があります。
	このファイルはそれぞれのサーバとクライアントに存在しなければならず、
	また Kerberos の運用において重要なものです。</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>このコマンドは一時的なファイルを作成するだけです。
	ファイル名をすべ てのサーバが読めるような
	<filename>srvtab</filename> という名前に変更しな
	ければなりません。
	&man.mv.1; コマンドを用いてシステムの場所に移動してください。</para>

      <screen>&prompt.root; mv grunt-new-srvtab srvtab</screen>

      <para>そのファイルがクライアントに配るためのもので、
	ネットワークが安全で はないと思われる場合には、<filename>
	  client-new-srvtab</filename>
	を移動
	可能なメディアにコピーして物理的に安全な方法で運んでください。
	クラ
	イアントの<filename>/etc/kerberosIV</filename>ディレクトリで、
	名前を <filename>srvtab</filename>に変更し、
	modeを600にするのを忘れないでください。</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>データベースへのユーザの追加</title>

      <para>ここで、
	ユーザのエントリをデータベースに追加する必要があります。
	始めに、
	ユーザ<systemitem class="username">jane</systemitem>のエントリを作成してみましょう。
	<command>kdb_edit</command>
	を用いて次のように作成してください。</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- 安全なパスワードを入れてください
Verifying password

<prompt>New Password:</prompt>                    &lt;---- もう一度パスワードを入れてください

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ? </prompt>
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>
    </sect2>

    <sect2>
      <title>すべてのテスト</title>

      <para>まず始めにKerberosデーモンを起動する必要があります。
	<filename>/etc/rc.conf</filename>
	ファイルを正しく編集してあれば、マシンを再
	起動することでに自動的にデーモンが起動します。
	これはKerberosサー バでのみ必要です。
	Kerberosクライアントは<filename>/etc/kerberosIV</filename>か
	ら必要なものを自動的に入手します。</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered.  BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>さあ、これで上で作成した <systemitem class="username">jane</systemitem>
	という ID のチケットを
	<command>kinit</command>コマンドで得ることができます。</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para><command>klist</command> コマンドを用いてトークンを見て、
	きちんとチケットを持って いるかどうか確認してください。</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>&man.passwd.1; コマンドを用いてパスワードを変更して、
	<application>kpasswd</application> デーモンが Kerberos
	データベースに対して認証されるかどうかチェックして
	ください。</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title><command>su</command> 特権の追加</title>

      <para>Kerberos は <systemitem class="username">root</systemitem> 権限が必要な
	<emphasis>各</emphasis> ユーザに対し、
	&man.su.1; のパスワードをユーザ毎に
	<emphasis>別のもの</emphasis> として持つことを可能にします。
	<systemitem class="username">root</systemitem> に &man.su.1;
	できる権利を与えられた ID を追加します。これは、
	principal に付いている <systemitem class="username">root</systemitem>
	というインスタンスに よって制御されています。
	<command>kdb_edit</command>を用いて
	<literal>jane.root</literal>というエントリを
	Kerberos データベースに作成します。</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key: </prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- 安全なパスワードを入れます
Verifying password

<prompt>New Password:</prompt>                    &lt;---- もう一回パスワードを入れます

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ? </prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- ここは短くしてください
<prompt>Attributes [ 0 ] ? </prompt>
Edit O.K.
<prompt>Principal name:</prompt>                  &lt;---- 何も入力しないと終了します</screen>

      <para>実際にトークンをもらって、
	ちゃんと働いているかどうか確認しましょう。</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password: </prompt></screen>

      <para>ここで <systemitem class="username">root</systemitem> ユーザの
	<filename>.klogin</filename>
	ファイルにユーザを追加する必要があります。</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>&man.su.1; してみましょう。</para>

      <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password: </prompt></screen>

      <para>どのトークンを持っているか見てみましょう。</para>

      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>他のコマンドの使用</title>

      <para>ここまでの例では、<literal>jane</literal> という principal
	を <literal>root</literal> とい
	うインスタンス付きで作成しました。
	これはユーザと同じ名前をprincipalと しており、
	Kerberosのデフォルトの値です;
	<literal>&lt;username&gt;.</literal><systemitem class="username">root</systemitem>
	という形式の
	<literal>&lt;principal&gt;.&lt;instance&gt;</literal>で、
	必要なエントリが <systemitem class="username">root</systemitem> のホームディレクトリの
	<filename>.klogin</filename> ファイルにあれば、
	<literal>&lt;username&gt;</literal> が
	<systemitem class="username">root</systemitem> に
	&man.su.1; できます。</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>同様に、ユーザのホームディレクトリの
	<filename>.klogin</filename>ファイルに次の
	ような行がある場合には</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>

      <para><systemitem class="username">jane</systemitem> または <systemitem class="username">jack</systemitem>
	という名前で (前述の<command>kinit</command> によって)
	認証されている <literal>EXAMPLE.COM</literal>
	という管理領域のユーザ なら誰でも &man.rlogin.1; や
	&man.rsh.1;, &man.rcp.1; 等によってこのシステム
	(<systemitem>grunt</systemitem>)
	の<systemitem class="username">jane</systemitem>のアカウントまたはファ
	イルにアクセスできます。</para>

      <para>たとえば、<systemitem class="username">jane</systemitem> が他のシステムに
	Kerberos を用いて login します。</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password: </prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>次の例では、<systemitem class="username">jack</systemitem>
	が同じマシンの <systemitem class="username">jane</systemitem>
	のアカウントに login します
	(<systemitem class="username">jane</systemitem> は
	<filename>.klogin</filename> ファイルを前述のように設定しており、
	Kerberos では <emphasis>jack</emphasis> という principal
	をインスタンスなしで設定してあります)。</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password: </prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
	The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberos5">
    <info><title><application>Kerberos5</application></title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tillman</firstname>
	    <surname>Hodgson</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mark</firstname>
	    <surname>Murray</surname>
	  </personname>
	  <contrib>基にした文書の執筆: </contrib>
	</author>
      </authorgroup>
    </info>

    <para>&os;-5.1 リリース以降のすべての &os; には、
      <application>Kerberos5</application> のみが含まれています。
      <application>Kerberos5</application>
      はインストールされている唯一のバージョンであり、設定は、多くの側面で
      <application>KerberosIV</application> と似ています。
      以下の情報は、&os;-5.0 リリース以降の
      <application>Kerberos5</application> のみに適応が可能です。
      <application>KerberosIV</application> package
      を使いたいと考えているユーザは、
      <filename role="package">security/krb4</filename> port
      をインストールしてください。</para>

    <para><application>Kerberos</application> は、
      サーバのサービスによってユーザが安全に認証を受けられるようにするための、
      ネットワークの付加システムおよびプロトコルです。
      リモートログイン、リモートコピー、
      システム間でのファイルのコピーおよび他のリスクの高いタスクをかなり安全に、
      そしてこれまでより制御できるようになります。</para>

    <para><application>Kerberos</application> は、
      身元確認プロキシシステムや、
      信頼される第 3 者認証システムとも説明されます。
      <application>Kerberos</application> は、一つの機能 &mdash;
      ネットワーク上のユーザの安全な認証 &mdash;
      だけを提供します。
      承認 (どのユーザが許可されているか)
      や監査 (ユーザがどのような作業を行っているか)
      の機能は提供しません。
      <application>Kerberos</application> を使って、
      クライアントおよびサーバの身元を証明した後は、
      日常業務におけるすべての通信を暗号化して、
      プライバシおよびデータの完全性を保証することができます。</para>

    <para>そのため、<application>Kerberos</application> を使う際は、
      承認および監査サービスを提供する他のセキュリティの手段との利用が、
      強く推奨されます。</para>

    <para>以下の文章は、&os; 用として配布されている
      <application>Kerberos</application>
      をセットアップする際のガイドとして利用できますが、
      完全な説明が必要な場合には、
      マニュアルページを参照してください。</para>

    <para>この節における <application>Kerberos</application>
      のインストールのデモでは、以下のような名前空間が使われます。</para>

    <itemizedlist>
      <listitem>
	<para><acronym>DNS</acronym> ドメイン (<quote>ゾーン</quote>) は、
	  example.org です。</para>
      </listitem>

      <listitem>
	<para><application>Kerberos</application> の領域は、
	  EXAMPLE.ORG です。</para>
      </listitem>
    </itemizedlist>

    <note>
      <para><application>Kerberos</application> の設定では、
	内部での使用でも実際のドメイン名を使ってください。
	<acronym>DNS</acronym> の問題を避けることができ、
	他の <application>Kerberos</application> のレルム (realm)
	との相互運用を保証します。</para>
    </note>

    <sect2>
      <title>歴史</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>歴史</secondary>
      </indexterm>

      <para><application>Kerberos</application> は、
	ネットワークのセキュリティ問題を解決するために、
	<acronym>MIT</acronym> で開発されました。
	<application>Kerberos</application> プロトコルは、
	必ずしも安全ではないインターネット接続においても、
	サーバに対して (逆もまた同様に)、
	強い暗号を使って身元を証明します。</para>

      <para><application>Kerberos</application> は、
	ネットワーク認証プロトコルの名前であり、
	このプログラムを実装しているプログラムを表す
	(例 <application>Kerberos</application> telnet)
	ための形容詞でもあります。
	プロトコルの現在のバージョンはバージョン 5 で、
	<acronym>RFC</acronym>&nbsp;1510 として文書化されています。</para>

      <para>このプロトコルのいくつものフリーの実装が、
	さまざまなオペレーティングシステムで利用できます。
	最初の <application>Kerberos</application>
	を開発したマサチューセッツ工科大学 (<acronym>MIT</acronym>) は、
	開発した <application>Kerberos</application>
	パッケージを継続的に保守しています。
	<acronym>アメリカ合衆国</acronym>では暗号製品として良く使われていますが、
	歴史的には、
	<acronym>アメリカ合衆国</acronym> の輸出規制により制限されてきました。
	<acronym>MIT</acronym> で実装された
	<application>Kerberos</application> は、port
	(<filename role="package">security/krb5</filename>)
	から利用できます。
	バージョン 5 のもう一つの実装が、
	Heimdal	<application>Kerberos</application>
	です。
	この実装は、<acronym>アメリカ合衆国</acronym>の外で開発されたため、
	輸出の制限を避けることができます
	(そのため、非商用の &unix;-like なシステムによく含まれています)。
	Heimdal <application>Kerberos</application> は port
	(<filename role="package">security/heimdal</filename>)
	からインストールできますが、最小構成は
	&os; の base インストールに含まれています。</para>

      <para>幅広い読者を対象とするために、以下の説明では
        &os; に含まれている Heimdal
        ディストリビューションの使用を想定しています。</para>
    </sect2>

    <sect2>
      <title>Heimdal <acronym>KDC</acronym> の設定</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>鍵配布センター</secondary>
      </indexterm>

      <para>鍵配布センター (<acronym>KDC</acronym>) は、
	<application>Kerberos</application>
	が提供する中心的な認証サービス
	&mdash; <application>Kerberos</application>
	チケットを発行するコンピュータです。
	<acronym>KDC</acronym> は、
	<application>Kerberos</application>
	のレルムの中のすべてのコンピュータから
	<quote>信頼</quote>されています。
	そのため、厳重なセキュリティに対する配慮が必要となります。</para>

    <para><application>Kerberos</application>
	サーバの実行にコンピュータのリソースは必要ありませんが、
	セキュリティの観点から、<acronym>KDC</acronym>
	としてのみ機能する専用のコンピュータが推奨されます。</para>

    <para><acronym>KDC</acronym> を設定するにあたって、
	<acronym>KDC</acronym> として動作するために、
	適切に <filename>/etc/rc.conf</filename> が設定されていること
	(システムを反映するようにパスを調整する必要があります)
	を確認してください。</para>

    <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
kerberos_stash="YES"</programlisting>

      <note>
	<para><option>kerberos_stash</option> は、
	  &os; 4.X でのみ利用可能です。</para>
      </note>

      <para>次に、<application>Kerberos</application>
	の設定ファイル <filename>/etc/krb5.conf</filename>
	を編集します。</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para><filename>/etc/krb5.conf</filename> ファイルの中では、
	<acronym>KDC</acronym> は、
	完全修飾されたホスト名 
	<systemitem class="fqdomainname">kerberos.example.org</systemitem>
	を持つことが想定されていることに注意してください。
	<acronym>KDC</acronym> が異なるホスト名である場合には、
	名前の解決が行われるように、適切に CNAME (エイリアス)
	エントリをゾーンファイルに追加する必要があります。</para>

      <note>
	<para>適切に <acronym>BIND</acronym> <acronym>DNS</acronym>
	  サーバが設定されたネットワークでは、
	  上記の例は、以下のように整理されます。</para>

	<programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>そして、<systemitem
	    class="fqdomainname">kerberos.EXAMPLE.ORG</systemitem>
	  ゾーンファイルには、以下の行が付け加えられます。</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG.</programlisting></note>

      <note>
        <para>クライアントが、
          <application>Kerberos</application> サービスを見つけるためには、
          <filename>/etc/krb5.conf</filename> を完全に設定するか、
          <filename>/etc/krb5.conf</filename> を最低限に設定し、
	  <emphasis>さらに</emphasis> DNS サーバを適切に設定する
	  <emphasis>必要</emphasis> があります。</para>
      </note>

      <para>次に <application>Kerberos</application> データベースを作成します。
	このデータベースには、
	マスター鍵により暗号化されたすべてのプリンシパルの鍵があります。
	このパスワードは、ファイル
	(<filename>/var/heimdal/m-key</filename>) に保存されるため、
	覚える必要はありません。
	マスター鍵を作成するには、<command>kstash</command> を実行して、
	パスワードを入力してください。</para>

      <para>マスター鍵を作成したら、<command>kadmin</command> プログラムを
	<literal>-l</literal> オプション (<quote>local</quote> を意味します)
	で実行し、初期化します。
	このオプションを使うと、<command>kadmin</command> は、
	<command>kadmind</command> ネットワークサービスを使わず、
	直接データベースファイルを変更します。
	これにより、
	データベースを作成する前に、データベースへの接続を試みてしまうという、
	卵が先か鶏が先かという問題を回避できます。
	<command>kadmin</command>
	プロンプトが表示されたら、<command>init</command> コマンドを使って、
	レルムに関する初期のデータベースを作成してください。</para>

      <para>最後に、<command>kadmin</command> プロンプトで
	<command>add</command>
	コマンドを使って最初のプリンシパルを作成して下さい。
	差し当たりは、
	プリンシパルに対するデフォルトのオプションに従ってください。
	後で <command>modify</command> コマンドを使うことで、
	いつでも変更することができます。
	プロンプトで <literal>?</literal> コマンドを使うと、
	利用可能なオプションを確認できます。</para>

      <para>データベース作成のセッションの例は以下のようになります。</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>これで <acronym>KDC</acronym>
	サービスを起動することができるようになりました。
	<command>/etc/rc.d/kerberos start</command> および
	<command>/etc/rc.d/kadmind start</command>
	を実行してサービスを起動してください。
	この時点で、kerberos 化されたデーモンが走っていなくても、
	<acronym>KDC</acronym> のコマンドラインから、作成したばかりの (ユーザ)
	プリンシパルのチケットを入手したり、
	一覧を表示することができることを確認してください。</para>

      <screen>&prompt.user; <userinput>k5init <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>k5list</userinput>
Credentials cache: FILE:<filename>/tmp/krb5cc_500</filename>
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      </sect2>

      <sect2>
	<title>Heimdal <application>Kerberos</application>
	  サービスを有効にする。</title>

        <indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>Enabling サービス</secondary>
        </indexterm>

	<para>最初に <application>Kerberos</application>
	  の設定ファイル <filename>/etc/krb5.conf</filename>
	  のコピーが必要です。
	  コピーを行うには、<acronym>KDC</acronym> から、
	  クライアントコンピュータへ
	  (&man.scp.1; のようなネットワークユーティリティを使うか、
	  物理的にフロッピーディスクを使って)
	  安全な方法でコピーをしてください。</para>

	<para>次に <filename>/etc/krb5.keytab</filename>
	  ファイルが必要となります。
	  これは、<application>Kerberos</application>
	  化されたデーモンを提供するサーバとワークステーションの間での大きな違いです
	  &mdash; サーバは、
	  <filename>keytab</filename> ファイルを持っている必要があります。
	  このファイルには、サーバのホスト鍵が含まれています。
	  この鍵により、ホストおよび
	  <acronym>KDC</acronym> が他の身元の検証ができます。
	  鍵が公開されてしまうと、
	  サーバのセキュリティが破れてしまうため、
	  このファイルは安全にサーバに転送しなければなりません。
	  このことは、<acronym>FTP</acronym>
	  のようにテキストチャネルでの転送は、
	  まったく好ましくないことを意味しています。</para>

	<para>一般的には、<command>kadmin</command> プログラムを使って、
	  <filename>keytab</filename> をサーバに転送します。
	  <command>kadmin</command> を使って
	  (<acronym>KDC</acronym> 側の
	  <filename>krb5.keytab</filename> に)
	  ホストプリンシパルを作成することも必要なので便利です。</para>

	<para>すでにチケットを入手し、
	  そのチケットは、
	  <command>kadmin</command> インタフェースで使用できることが
	  <filename>kadmind.acl</filename>
	  で許可されている必要があります。
	  アクセスコントロールリストの設計の詳細については、
	  Heimdal info ページ (<command>info heimdal</command>) の
	  <quote>Remote administration</quote>
	  というタイトルの章をご覧ください。
	  リモートからの
	  <command>kadmin</command> アクセスを有効にしたくない場合は、
	  安全に (ローカルコンソール、&man.ssh.1; もしくは
	  <application>Kerberos</application> &man.telnet.1; を用いて)
	  <acronym>KDC</acronym> に接続し、
	  <command>kadmin -l</command> を使用して、
	  ローカルで管理作業を行ってください。</para>

	<para><filename>/etc/krb5.conf</filename>
	  ファイルをインストールしたら、
	  <application>Kerberos</application> サーバから、
	  <command>kadmin</command> を使うことができます。
	  <command>add --random-key</command> コマンドを使うと、
	  サーバのホストプリンシパルを追加できます。
	  そして、<command>ext</command> コマンドを用いて、
	  サーバのホストプリンシパルを keytab に抽出してください。</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>

kadmin><userinput> add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin><userinput> ext host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para><command>ext</command> コマンド (<quote>extract</quote>
	  の省略形) は、デフォルトでは、抽出された鍵を
	  <filename>/etc/krb5.keytab</filename> に保存します。</para>

	<para><acronym>KDC</acronym> 上で <command>kadmind</command>
	  を (おそらくセキュリティ上の理由から) 走らせていない場合で、
	  リモートから <command>kadmin</command> に接続出来ない場合には、
	  ホストプリンシパル (<systemitem
	    class="username">host/myserver.EXAMPLE.ORG</systemitem>) 
	  を直接 <acronym>KDC</acronym> 上で追加し、
	  その後、以下のように
	  (<acronym>KDC</acronym> 上の
	  <filename>/etc/krb5.keytab</filename> の上書きを避けるため)、
	  一時ファイルに抽出してください。</para>

	<screen>&prompt.root; <userinput>kadmin</userinput>
kadmin><userinput> ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin><userinput> exit</userinput></screen>

	<para>その後、keytab を安全に (たとえば
	  <command>scp</command> またはフロッピーを使って)
	  サーバコンピュータにコピーしてください。
	  <acronym>KDC</acronym> 上の keytab を上書きすることを避けるため、
	  デフォルトとは異なる名前を指定してください。</para>

	<para>これでサーバは、
	  (<filename>krb5.conf</filename> ファイルにより)
	  <acronym>KDC</acronym> と通信ができるようになりました。
	  そして、(<filename>krb5.keytab</filename> ファイルによって)
	  身元を証明できるようになったので、
	  <application>Kerberos</application>
	  サービスを有効にする準備が出来ました。
	  この例では、以下の行を
	  <filename>/etc/inetd.conf</filename> に加え、
	  <command>telnet</command>
	  サービスを有効にしてください。その後、
	  <command>/etc/rc.d/inetd restart</command> にて
	  &man.inetd.8; サービスを再起動します。</para>

	<programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

	<para>重要な箇所は、ユーザに <command>-a</command>
	  (認証を表す) が設定されていることです。
	  詳細については、
	  &man.telnetd.8; マニュアルページを参照してください。</para>
      </sect2>

      <sect2>
	<title>Heimdal <application>Kerberos</application>
	  クライアントを有効にする</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>クライアントの設定</secondary>
	</indexterm>

	<para>クライアントコンピュータの設定は、
	  ほとんど取るに足らないくらいに簡単です。
	  <application>Kerberos</application> の設定がうまくいっていれば、
	  <filename>/etc/krb5.conf</filename> に置かれている
	  <application>Kerberos</application>
	  の設定ファイルのみが必要です。
	  セキュリティ的に安全な方法で、<acronym>KDC</acronym>
	  からクライアントコンピュータへ単にコピーしてください。</para>

	<para>クライアントから、<command>kinit</command>,
	  <command>klist</command> および
	  <command>kdestroy</command> を使用し、
	  上記で作成したプリンシパルに対するチケットの入手、表示、
	  削除を行い、クライアントコンピュータを試験してください。
	  <application>Kerberos</application>
	  アプリケーションを使って <application>Kerberos</application>
	  が有効なサーバに接続することもできるはずです。
	  もしうまく機能しない場合でも、チケットを入手できるのであれば、
	  問題はおそらくサーバにあり、
	  クライアントまたは <acronym>KDC</acronym>
	  の問題ではないと考えられます。</para>

	<para><command>telnet</command>
	  のようなアプリケーションを試験する際には、
	  (&man.tcpdump.1; といった) パケットスニファを使用して、
	  パスワードが平文で送られていないことを確認してください。
	  <literal>-x</literal> オプションで
	  <command>telnet</command> を利用すると、
	  (<command>ssh</command> のように)
	  すべてのデータストリームが暗号化されます。</para>

	<para><application>Kerberos</application>
	  のコアのクライアントアプリケーション
	  (伝統的に、<command>kinit</command>,
	  <command>klist</command>, <command>kdestroy</command> および
	  <command>kpasswd</command> という名前です) は、&os;
	  のベースにインストールされています。
	  5.0 以前の &os; では、
	  <command>k5init</command>,
	  <command>k5list</command>, <command>k5destroy</command>,
	  <command>k5passwd</command> および <command>k5stash</command>
	  と言う名前でインストールされています。
	  これらは通常一度しか用いられません。</para>

	<para>デフォルトでは、Heimdal インストールの
	  <quote>最小</quote> と考えられる、コア以外の
	  <application>Kerberos</application> 
	  クライアントアプリケーションもインストールされます。
	  <command>telnet</command> は、
	  <application>Kerberos</application>
	  化された唯一のサービスです。</para>

	<para>Heimdal port は、
	  <application>Kerberos</application> 化されている
	  <command>ftp</command>, <command>rsh</command>,
	  <command>rcp</command>, <command>rlogin</command>
	  および他のあまり一般的ではないプログラムといった、
	  インストールされていないクライアントアプリケーションをインストールします。
	  <acronym>MIT</acronym> port も、すべての
	  <application>Kerberos</application>
	  クライアントアプリケーションをインストールします。</para>
      </sect2>

      <sect2>
	<title>ユーザ設定ファイル: <filename>.k5login</filename>
	  および <filename>.k5users</filename></title>

	<indexterm>
	  <primary><filename>.k5login</filename></primary>
	</indexterm>

	<indexterm>
	  <primary><filename>.k5users</filename></primary>
	</indexterm>

	<para>レルムのユーザは、一般的には、
	  (<systemitem class="username">tillman</systemitem>
	  のような) ローカルユーザアカウントに対応する
	  (<systemitem class="username">tillman@EXAMPLE.ORG</systemitem>
	  といった) <application>Kerberos</application>
	  プリンシパルを持ちます。
	  <command>telnet</command>
	  のようなクライアントアプリケーションは、
	  ユーザ名もしくはプリンシパルを通常必要としません。</para>

	<para>しかしながら、時々
	  <application>Kerberos</application>
	  プリンシパルに対応しないローカルユーザアカウントへのアクセスが必要となることがあります。
	  たとえば、
	  <systemitem class="username">tillman@EXAMPLE.ORG</systemitem>
	  が、ローカルユーザアカウント
	  <systemitem class="username">webdevelopers</systemitem>
	  へのアクセスが必要となることがあります。
	  そして、他のプリンシパルが同じローカルアカウントにアクセスが必要になることもあります。 </para>

	<para>ユーザのホームディレクトリに置かれた
	  <filename>.k5login</filename> および
	  <filename>.k5users</filename> ファイルによって
	  (<filename>.hosts</filename> および <filename>.rhosts</filename>
	  の強力な組み合わせのように)、この問題を解決出来ます。
	  たとえば、以下の行を含む
	  <filename>.k5login</filename> を</para>

	<screen>tillman@example.org
jdoe@example.org</screen>

	<para>ローカルユーザ
	  <systemitem class="username">webdevelopers</systemitem>
	  のホームディレクトリに置くと、
	  一覧にある両方のプリンシパルは、
	  共有のパスワードを必要としなくても、
	  このアカウントにアクセス出来ます。</para>

	<para>これらのコマンドのマニュアルページを読むことが推奨されます。
	  <command>ksu</command> マニュアルページには、
	  <filename>.k5users</filename> の説明があります。</para>
      </sect2>

      <sect2>
	<title><application>Kerberos</application> Tips, Tricks, およびトラブルシューティング</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>トラブルシューティング</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	    <para>Heimdal または <acronym>MIT</acronym>
	      <application>Kerberos</application> ports
	      のどちらを使う場合でも、
	      <envar>PATH</envar> 環境変数は、
	      <application>Kerberos</application> 版のクライアント
	      アプリケーションが、
	      システムにあるアプリケーションより先に見つかるように設定されていることを確認してください。</para>
	  </listitem>

	  <listitem>
	    <para>レルムにあるすべてのコンピュータの間で時刻が同期していますか？
	      時刻が同期していないと認証に失敗してしまいます。
	      <acronym>NTP</acronym> を用いた、時刻の同期方法については、
	      <xref linkend="network-ntp"/> をご覧ください。</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym> および Heimdal 間の運用は、
	      標準化されていないプロトコル <command>kadmin</command> を除き、
	      うまく機能します。</para>
	  </listitem>

	  <listitem>
	    <para>ホスト名を変更する際は、
	      <systemitem class="username">host/</systemitem>
	      プリンシパルを変更し、keytab をアップデートする必要があります。
	      Apache の
	      <filename role="package">www/mod_auth_kerb</filename>
	      で使われる
	      <systemitem class="username">www/</systemitem>
	      プリンシパルのような特別な
	      keytab エントリでも必要となります。</para>
	  </listitem>

	  <listitem>
	    <para>レルムの中のすべてのホストは、<acronym>DNS</acronym>
	      において (もしくは、最低限<filename>/etc/hosts</filename>
	      の中で)、(正引きおよび逆引き両方で)
	      名前解決できる必要があります。
	      CNAME は動作しますが、A および PTR レコードは、
	      正しく適切な位置に記述されている必要があります。
	      エラーメッセージは、
	      次の例のように、直感的に原因が分かるようなものではありません。
	      <errorname>Kerberos5 refuses authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	  </listitem>

	  <listitem>
	    <para><acronym>KDC</acronym>
	      に対しクライアントとして振る舞うオペレーティングシステムの中には、
	      <command>ksu</command> に対して、
	      <systemitem class="username">root</systemitem> 権限に
	      setuid を許可しないものがあります。
	      この設定では、
	      <command>ksu</command> は動作しないことを意味します。
	      セキュリティの観点からは好ましい考えですが、
	      厄介です。これは
	      <acronym>KDC</acronym> のエラーではありません。</para>
	  </listitem>

	  <listitem>
	    <para><acronym>MIT</acronym>
	      <application>Kerberos</application> において、
	      プリンシパルが、デフォルトの 10
	      時間を超えるチケットの有効期限としたい場合には、
	      <command>kadmin</command>	で
	      <command>modify_principal</command> を使って、
	      対象のプリンシパルおよび
	      <systemitem class="username">krbtgt</systemitem>
	      プリンシパル両方の有効期限の最大値を変更してください。
	      プリンシパルは、
	      <command>kinit</command> で
	      <literal>-l</literal> オプションを使用して、
	      長い有効期限のチケットを要求できます。</para>
	  </listitem>

	  <listitem>
	    <note><para>トラブルシューティングのために、
	      <acronym>KDC</acronym> でパケットスニファを走らせ、
	      そして、ワークステーションから
	      <command>kinit</command> を実行すると、
	      <command>kinit</command> を実行するやいなや、
	      <acronym>TGT</acronym> が送られてきます。
	      &mdash;
	      あなたがパスワードを入力し終わる前でも! 
	      これに関する説明は、以下の通りです。
	      <application>Kerberos</application> サーバは、
	      いかなる未承認のリクエストに対して、
	      自由に <acronym>TGT</acronym> (Ticket Granting
	      Ticket) を送信します。しかしながら、すべての
	      <acronym>TGT</acronym> は、
	      ユーザのパスワードから生成された鍵により、暗号化されています。
	      そのため、ユーザがパスワードを入力した時には、
	      パスワードは <acronym>KDC</acronym> には送られません。
	      このパスワードは、<command>kinit</command> がすでに入手した
	      <acronym>TGT</acronym> の復号化に使われます。
	      もし、復号化の結果、
	      有効なチケットで有効なタイムスタンプの場合には、
	      ユーザは、有効な <application>Kerberos</application>
	      クレデンシャルを持ちます。
	      このクレデンシャルには、
	      <application>Kerberos</application>
	      サーバ自身の鍵により暗号化された実際の
	      ticket-granting ticket とともに、将来
	      <application>Kerberos</application>
	      サーバと安全な通信を確立するためのセッション鍵が含まれています。
	      この暗号の 2 番目のレイヤは、ユーザには知らされませんが、
	      <application>Kerberos</application> サーバが、
	      各 <acronym>TGT</acronym>
	      の真偽の検証を可能にしている部分です。</para></note>
	  </listitem>

	  <listitem>
	    <para>(たとえば一週間といった)
	      長い有効期限のチケットを使いたい場合で、
	      <application>OpenSSH</application> を使って、
	      チケットが保存されているコンピュータに接続しようとする場合は、
	      <application>Kerberos</application>
	      <option>TicketCleanup</option> が
	      <filename>sshd_config</filename> において
	      <literal>no</literal> と設定されているか、
	      チケットが、ログアウト時に削除されることを確認してください。</para>
	  </listitem>

	  <listitem>
	    <para>ホストプリンシパルも長い有効期限のチケットを持てることを覚えておいてください。
	      もし、ユーザプリンシパルが 1 週間の有効期限を持ち、
	      接続しているホストが、9 時間の有効期限を持っている場合には、
	      キャッシュのホストプリンシパル (の鍵) の有効期限が切れてしまい、
	      想定したように、チケットキャッシュが振る舞わないことが起こりえます。</para>
	  </listitem>

	  <listitem>
	    <para>特定の問題のあるパスワードが使われることを避けるために
	      (<command>kadmind</command> のマニュアルページでは、
	      この点について簡単に触れています)、
	      <filename>krb5.dict</filename> ファイルを設定する時には、
	      パスワードポリシが割り当てられたプリンシパルにのみ適用されることに注意してください。
	      <filename>krb5.dict</filename> ファイルの形式は簡単です。
	      : 一行に一つの文字列が置かれています。
	      <filename>/usr/share/dict/words</filename>
	      にシンボリックリンクを作成することは、有効です。</para>
	  </listitem>
        </itemizedlist>

      </sect2>

      <sect2>
	<title><acronym>MIT</acronym> port との違いについて</title>

	<para><acronym>MIT</acronym>
	  とインストールされている Heimdal 版の大きな違いは、
	  <command>kadmin</command> に関連しています。
	  このプログラムは、異なる (ただし等価な) コマンド群を持ち、そして、
	  異なるプロトコルを使用します。 
	  もし <acronym>KDC</acronym> に <acronym>MIT</acronym>
	  を使用している場合には、
	  Heimdal <command>kadmin</command>
	  プログラムを使って <acronym>KDC</acronym> をリモートから
	  (この場合は、逆も同様に) 管理できない
	  ことを意味しています。</para>

	<para>クライアントアプリケーションでは、同じタスクを行う際に、
	  若干異なるコマンドラインのオプションが必要となることもあります。
	  <acronym>MIT</acronym>
	  <application>Kerberos</application> ウェブサイト
	  (<link xlink:href="http://web.mit.edu/Kerberos/www/"></link>)
	  に書かれているガイドに従うことが推奨されます。
	  path の問題について注意してください。
	  <acronym>MIT</acronym> port はデフォルトで
	  <filename>/usr/local/</filename> にインストールします。
	  そのため、もし <envar>PATH</envar>
	  環境変数においてシステムのディレクトが最初に書かれている場合には、
	  <acronym>MIT</acronym> 版ではなく、
	  <quote>通常の</quote> システムアプリケーションが動いてしまいます。</para>

	<note><para>&os; が提供する <acronym>MIT</acronym>
	  <filename role="package">security/krb5</filename> port において、
	  <command>telnetd</command> および <command>klogind</command>
	  経由でのログインが奇妙な振る舞いをすることを理解したいのであれば、
	  port からインストールされる
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>
	  ファイルを読んで下さい。
	  最も重要なことは、
	  <quote>incorrect permissions on cache file</quote>
	  の振る舞いを修正するには、
	  フォワードされたクレデンシャリングの所有権を適切に変更できるように、
	  <command>login.krb5</command>
	  バイナリが認証に使われる必要があります。</para></note>
      </sect2>

      <sect2>
	<title><application>Kerberos</application>
	  で見つかった制限を緩和する</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>制限および欠点</secondary>
	</indexterm>

	<sect3>
	  <title><application>Kerberos</application> は、all-or-nothing
	    アプローチです。</title>

	  <para>ネットワーク上で有効なすべてのサービスは、
	    <application>Kerberos</application> 化
	    (または、ネットワーク攻撃に対して安全に) されるべきです。
	    さもないと、ユーザのクレデンシャルが盗まれ、
	    利用されることが起きるかもしれません。
	    この例は、
	    <application>Kerberos</application> 化されたすべてのリモートシェル
	    (たとえば、<command>rsh</command> および <command>telnet</command>)
	    です。
	    パスワードを平文で送るような
	    <acronym>POP3</acronym> メールサーバは変換していません。</para>
	</sect3>

	<sect3>
	  <title><application>Kerberos</application> は、
	    シングルユーザのワークステーションでの使用を想定しています。</title>

	  <para>マルチユーザの環境では、
	    <application>Kerberos</application> は安全ではありません。
	    チケットは <filename>/tmp</filename> ディレクトリに保管され、
	    このチケットは、すべてのユーザが読むことができるためです。
	    もし、ユーザがコンピュータを他のユーザと同時に共有
	    (i.e. マルチユーザで使用) していると、
	    他のユーザは、そのユーザのチケットを盗む
	    (コピーする) ことが出来てしまいます。</para>

	  <para>この問題は、<literal>-c</literal>
	    ファイル名コマンドラインオプションまたは、(好ましくは)
	    <envar>KRB5CCNAME</envar> 環境変数によって克服されますが、
	    実際に使われることはまれです。
	    大体においては、チケットをユーザのホームディレクトリに保存し、
	    簡単なファイルの許可属性を設定することで、
	    この問題に対応できます。</para>
	</sect3>

	<sect3>
	  <title>KDC は、単一障害点である</title>

	  <para>設計上、<acronym>KDC</acronym> は、
	    マスターパスワードのデータベースを含むため、
	    安全である必要があります。
	    <acronym>KDC</acronym> では、
	    絶対に他のサービスを走らせるべきではありませんし、
	    物理的に安全であるべきです。
	    <application>Kerberos</application> は、
	    <acronym>KDC</acronym> 上で、ファイルとして保存されている一つの鍵
	    (<quote>マスター</quote> 鍵)
	    で暗号化されたすべてのパスワードを保存しているので、
	    非常に危険です。</para>

	  <para>追記ですが、マスター鍵が漏洩しても、
	    通常懸念するほど悪いことにはなりません。
	    マスター鍵は、<application>Kerberos</application>
	    データベースの暗号時にのみ、
	    乱数を生成するためのシードとして使われます。
	    <acronym>KDC</acronym> へのアクセスが安全である限りにおいては、
	    マスター鍵を用いて、それほど多くのことはできません。</para>

	  <para>さらに、<acronym>KDC</acronym> が
	    (DoS 攻撃またはネットワーク問題等により)
	    ネットワークサービスを利用できず、
	    認証ができない場合に対する、DoS 攻撃への対応方法があります。
	    この攻撃による被害は、
	    複数の <acronym>KDC</acronym>
	    (ひとつのマスタとひとつまたはそれ以上のスレーブ)
	    および、セカンダリもしくはフォールバック認証
	    (これには、<acronym>PAM</acronym> が優れています)
	    の実装により軽減することができます。</para>
	</sect3>

	<sect3>
	  <title><application>Kerberos</application> の欠点</title>

	  <para><application>Kerberos</application> は、
	    ユーザ、ホストおよびサービスの間での認証を可能にしますが、
	    <acronym>KDC</acronym> とユーザ、
	    ホストまたはサービスとの間の認証のメカニズムは提供しません。
	    これは、(たとえば) トロイの木馬の
	    <command>kinit</command> が、
	    すべてのユーザ名とパスワードを記録できることを意味しています。
	    <filename role="package">security/tripwire</filename>
	    のような、
	    もしくは他のファイルシステムの完全性を確認するためのツールにより、
	    この危険性を軽減することができます。</para>
	</sect3>
      </sect2>

      <sect2>
	<title>リソースおよび他の情報源</title>

	<indexterm>
	  <primary>Kerberos5</primary>
	  <secondary>External Resources</secondary>
	</indexterm>

	<itemizedlist>
	  <listitem>
	  <para><link
	    xlink:href="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	    The <application>Kerberos</application> FAQ</link></para>
	</listitem>

	<listitem>
	  <para><link
	  xlink:href="http://web.mit.edu/Kerberos/www/dialogue.html">Designing
	    an Authentication System: a Dialog in Four Scenes</link></para>
	</listitem>

	<listitem>
	  <para><link
		    xlink:href="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    The <application>Kerberos</application> Network Authentication Service
	    (V5)</link></para>
	</listitem>

	<listitem>
	  <para><link
	  xlink:href="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application> home page</link></para>
	</listitem>

	<listitem>
	<para><link xlink:href="http://www.pdc.kth.se/heimdal/">Heimdal
	  <application>Kerberos</application> home page</link></para>
	</listitem>

	</itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="openssl">
    <info><title>OpenSSL</title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>執筆: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>

    <para>多くのユーザが見落としがちな機能の一つが、
      &os; に含まれている <application>OpenSSL</application>
      ツールキットです。
      <application>OpenSSL</application> は、
      通常の通信層の上位にあるトランスポート層を暗号化し、
      多くのネットワークアプリケーションおよびサービスと組み合わせて使用できます。</para>

    <para><application>OpenSSL</application> は、
      メールクライアントの暗号化された認証、
      クレジットカードでの支払いといったウェブベースの取引などで使われます。
      <filename role="package">www/apache13-ssl</filename> および
      <filename role="package">mail/sylpheed-claws</filename>
      といった多くの port では、
      <application>OpenSSL</application>
      とともに構築するコンパイルに対応しています。</para>

    <note>
      <para>多くの場合、Ports Collection は、
	make の WITH_OPENSSL_BASE 変数が明示的に
	<quote>yes</quote> に設定されていないと、
	<filename role="package">security/openssl</filename> port
	の構築を試みます。</para>
    </note>

    <para>&os; に含まれている <application>OpenSSL</application>
    　のバージョンは、Secure Sockets Layer v2/v3 (SSLv2/SSLv3) や
      Transport Layer Security v1 (TLSv1)
      ネットワークセキュリティプロトコルに対応しており、
      多目的な暗号化ライブラリとして使うことができます。</para>

    <note>
      <para><application>OpenSSL</application> は、
	<acronym>IDEA</acronym> アルゴリズムに対応していますが、
	合衆国の特許により、デフォルトでは無効になっています。
	もし使用したいのであれば、ライセンス条項を必ず確認し、
	ライセンス条項に合致するのであれば、
	MAKE_IDEA 変数を設定してください。</para>
    </note>

    <para>最も一般的な <application>OpenSSL</application>
      の利用方法のひとつは、
      ソフトウェアアプリケーションが使えるように証明書を提供することです。
      これらの証明書により、
      会社または個人の公開鍵が、
      改ざんやなりすましが行われていないことを確認できます。
      もし問題となっている証明書が、<quote>認証局</quote>
      または <acronym>CA</acronym> により検証されなければ、
      通常警告が表示されます。
      認証局は、<link xlink:href="http://www.verisign.com">VeriSign</link>
      のような会社で、個人または会社の公開鍵の検証を行えるように、
      証明書に署名を行います。
      証明書を作成するには費用がかかり、
      証明書の使用は必ずしも必要条件ではありません。
      しかしながら、証明書を使うことで、
      疑り深いユーザを安心させることができます。</para>

    <sect2>
      <title>証明書の作成</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>証明書の作成</secondary>
      </indexterm>

      <para>以下のコマンドにより、証明書を作成できます。</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para><quote>Common Name</quote> プロンプト直後に表示されているのは、
	ドメイン名です。
	このプロンプトでは、検証するサーバ名の入力が必要となります。
	ドメイン名以外を入力すると、役に立たない証明書が作成されます。
	他には、有効期限を指定したり、
	別の暗号化アルゴリズムを選択することができます。
	オプションの完全なリストは、
	&man.openssl.1; マニュアルページで確認できます。</para>

      <para>前述のコマンドを実行したディレクトリには、
	2 つのファイルが作成されているはずです。
	1 つは、証明書要求 <filename>req.pem</filename> です。
	このファイルを認証局に送ると、
	認証局は含まれている内容を検証し、
	検証に成功すると、証明書要求に署名を行い、
	作成された証明書を送り返します。
	もうひとつ、<filename>cert.pem</filename>
	と呼ばれるファイルが生成されます。
	これは証明書の秘密鍵であり、
	どのようなことがあっても保護しなくてはなりません。
	もし、他の人の手に渡ると、手に入れた人は、
	あなた (もしくはあなたのサーバ)
	になりすますことができてしまいます。</para>

      <para><acronym>CA</acronym> の署名が必要ない場合には、
	自己署名証明書を作成できます。
	最初に <acronym>RSA</acronym> の鍵を生成してください。</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out <filename>myRSA.key</filename> 1024</userinput></screen>
	
	<para>次に、<acronym>CA</acronym> 鍵を生成してください。</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out <filename>myca.key</filename> <filename>myRSA.key</filename></userinput></screen>

      <para>この鍵を使って証明書を作成してください。</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key <filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>新しく 2 つのファイルがこのディレクトリに作成されます。
	プライベート鍵 <filename>myca.key</filename> および
	証明書 <filename>new.crt</filename> です。
	これらのファイルを、(好ましくは
	<filename class="directory">/etc</filename> 以下で)
	<systemitem class="username">root</systemitem>
	のみが読むことのできるディレクトリに置く必要があります。
	<command>chmod</command>
	ユーティリティを使って許可属性を 0700 に設定してください。</para>
    </sect2>

    <sect2>
      <title>証明書の使用例</title>

      <para>これらのファイルで何ができるでしょうか?
	効果的な利用方法は、
	<application>Sendmail</application>
	<acronym>MTA</acronym> への接続を暗号化することでしょう。
	これにより、
	ローカルの <acronym>MTA</acronym> 経由でメールを送信するユーザが、
	テキスト認証を使用しなくてもすむようになります。</para>

      <note>
	<para>いくつかの <acronym>MUA</acronym> は、
	  証明書がローカルにインストールされていない場合に、
	  ユーザに対して、エラーを出力するので、
	  完全に最善の利用方法というわけではありません。
	  証明書のインストールに関する詳細な情報については、
	  ソフトウェアに付随の文書を参照してください。</para>
      </note>

      <para>以下の行をローカルの
	<filename>.mc</filename> ファイルに入れてください。</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>ここで <filename class="directory">/etc/certs/</filename>
	は、証明書および鍵ファイルが保存されているローカルのディレクトリです。
	最後に、ローカルの <filename>.cf</filename>
	ファイルを再構築する必要があります。
	<filename class="directory">/etc/mail</filename> ディレクトリで、
	<command>make</command>	<parameter>install</parameter>
	と入力すると再構築できます。
	その後、<command>make</command>
	<parameter>restart</parameter> と入力して、
	<application>Sendmail</application>
	デーモンを再起動してください。</para>

      <para>すべてがうまくいっていれば、
	<filename>/var/log/maillog</filename>
	ファイルにはエラーメッセージは出力されず、
	<application>Sendmail</application>
	がプロセスの一覧に表示されます。</para>

      <para>以下は簡単な試験の例で、&man.telnet.1; ユーティリティを使って、
	メールサーバに接続しています。</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to  <systemitem class="ipaddress">example.com</systemitem>
Escape character is '^]'.
220 <systemitem class="ipaddress">example.com</systemitem> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <systemitem class="ipaddress">example.com</systemitem> closing connection
Connection closed by foreign host.</screen>

      <para>すべてが適切に動いていれば、出力に <quote>STARTTLS</quote>
	行が表示されます。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ipsec">
    <info><title>VPN over IPsec</title>
      <authorgroup>
        <author>
	  <personname>
  	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	  </personname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation>
          <contrib>執筆: </contrib>
        </author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <para>この章では、FreeBSD ゲートウェイを使って、
      インターネットによって分けられた、二つのネットワーク間に
      VPN を作成します。</para>

    <sect2>
      <info><title>IPsec を理解する</title>
        <authorgroup>
          <author>
	    <personname>
	      <firstname>Hiten M.</firstname>
	      <surname>Pandya</surname>
	    </personname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>執筆: </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>この節では、FreeBSD と
	<application>&microsoft.windows; 2000/XP</application>
	からなる環境において、IPsec を設定し、利用する過程を通じて、
	IPsec を使った安全な通信の実現方法について解説します。
	IPsec を設定するためには、
	カスタムカーネルの構築方法をよく知っている必要があります
	(<xref linkend="kernelconfig"/> をご覧ください)。</para>
	
      <para><emphasis>IPsec</emphasis> は、インターネットプロトコル (IP)
	レイヤのトップにあるプロトコルです。
	二つもしくはそれ以上のホスト間で安全に通信することを可能にします
	(そのため、名前に sec が含まれています)。
	FreeBSD の IPsec <quote>ネットワークスタック</quote> は、
	IPv4 および IPv6 の両方のプロトコルファミリに対応している
	<link xlink:href="http://www.kame.net/">KAME</link>
	実装をベースとしています。</para>

      <note>
        <para>FreeBSD 5.X では <quote>hardware
          accelerated</quote> IPsec スタックが追加されました。
	  これは、<quote>Fast IPsec</quote> として知られているもので、
	  OpenBSD から移植されました。
	  IPsec のパフォーマンスを最適化するために、(利用できる場合には)
	  &man.crypto.4; サブシステムを経由して、
	  暗号ハードウェアを使用します。
	  このサブシステムは新しいので、まだ IPsec の KAME
	  版で利用可能な機能のすべてに対応しているわけではありません。
	  しかしながら、hardware-accelerated IPsec を有効にするためには、
	  カーネルコンフィグレーションファイルに以下のカーネルオプションを追加する必要があります。</para>

	<indexterm>
	  <primary>カーネルオプション</primary>
	  <secondary>FAST_IPSEC</secondary>
	</indexterm>

        <screen>
options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)
        </screen>

        <para>現在の時点では、<quote>Fast IPsec</quote>
	  サブシステムを IPsec の KAME 実装のかわりに使うことはできません。
	  より多くの情報については、&man.fast.ipsec.4;
	  を参照してください。</para>
      </note>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>ESP</secondary>
      </indexterm>
  
      <indexterm>
	<primary>IPsec</primary>
	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec は二つのサブプロトコルから構成されます。</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload
	      (ESP)</emphasis> は、(Blowfish, 3DES のような)
	    対称暗号アルゴリズムを使ってデータを暗号化することで、
	    サードパーティのインタフェースから
	    IP パケットデータを保護します。</para>
        </listitem>
        <listitem>
          <para><emphasis>Authentication Header (AH)</emphasis>,
	    は、暗号チェックサムを計算し、IP
	    パケットのヘッドフィールドを安全なハッシュ関数でハッシュ化することで、
	    IP パケットヘッダをサードパーティのインタフェースやなりすましから守ります。
	    ハッシュを含む追加のヘッダが追加され、
	    パケット情報の検証が可能になります。</para>
        </listitem>
      </itemizedlist>
      
      <para><acronym>ESP</acronym> および <acronym>AH</acronym>
	は、使用する環境に合わせて、
	一緒に使うことも別々に使うこともできます。</para>

      <indexterm>
	<primary>VPN</primary>
      </indexterm>

      <indexterm>
	<primary>virtual private network</primary>
	<see>VPN</see>
      </indexterm>

      <para>IPsec は、直接二つのホスト間のトラフィックを暗号化する
	<emphasis>Transport Mode</emphasis>、もしくは、
	2 つの共同するネットワーク間で安全に通信することを可能にするように、
	2 つのサブネット間に <quote>virtual tunnels</quote> を構築する
	<emphasis>Tunnel Mode</emphasis> のどちらでも用いることができます。
	後者はより一般的には、
	<emphasis>Virtual Private Network (VPN)</emphasis>
	として知られています。
	FreeBSD での IPsec サブシステムに関するより詳細な情報については、
	&man.ipsec.4; マニュアルページを参照してください。</para>
      
      <para>カーネルに IPsec のサポートを追加するには、
	カーネルコンフィグレーションファイルに以下のオプションを追加してください。</para>

      <indexterm>
	<primary>カーネルオプション</primary>
	<secondary>IPSEC</secondary>
      </indexterm>

      <indexterm>
	<primary>カーネルオプション</primary>
	<secondary>IPSEC_ESP</secondary>
      </indexterm>

      <screen>
options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)
      </screen>

      <indexterm>
	<primary>カーネルオプション</primary>
	<secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>IPsec のデバッグサポートが必要であれば、
	以下のカーネルオプションを追加してください。</para>

      <screen>
options   IPSEC_DEBUG  #debug for IP security
      </screen>
    </sect2>

    <sect2>
      <title>問題点</title>
 
      <para>VPN の構成についての標準はありません。
	VPN は、数多くの技術と共に実装することが可能です。
	その各技術には、それ自身の長所と短所があります。
	この章では、シナリオを示し、
        そのシナリオに対して、VPN を実装する戦略について説明します。</para>
    </sect2>

    <sect2>
      <title>シナリオ: インターネットに接続している 2 つのネットワークが
        1 つのネットワークとして振る舞う</title>

      <indexterm>
	<primary>VPN</primary>
	<secondary>creating</secondary>
      </indexterm>

      <para>前提は以下の通りです。</para>
      
      <itemizedlist>
        <listitem>
          <para>少なくとも 2 つのサイトを持っています。</para>
        </listitem>
        <listitem>
          <para>どちらの際とも内部で IP を使っています。</para>
        </listitem>
        <listitem>
          <para>2 つのサイトは、FreeBSD で運用されているゲートウェイを通して、
	    インターネットに接続しています。</para>
        </listitem>
        <listitem>
          <para>それぞれのネットワークのゲートウェイは、
	    少なくとも一つのパブリック IP アドレスを持っています。</para>
        </listitem>
        <listitem>
          <para>2 つのネットワークの内部アドレスは、
	    パブリックでもプライベート IP アドレスでも構いません。
	    必要であれば、ゲートウェイコンピュータで
	    NAT を走らせることもできます。</para>
        </listitem>
        <listitem>
          <para>2 つのネットワークの内部 IP アドレスは、
            <emphasis>衝突してはいけません</emphasis>。
	    VPN 技術と NAT を用いることで、理論的には、
	    そのようなことは可能と考えますが、
	    その設定は悪夢でしょう。</para>
        </listitem>
      </itemizedlist>
      
      <para>2 つのネットワークに接続を試みた際に、
        両方のネットワークで同じ範囲の内部 IP
	アドレスが使われていることに気づいたら
        (たとえば、両方で
	<systemitem class="ipaddress">192.168.1.x</systemitem>
	を使用している場合)、
	どちらかの番号を振りなおす必要があります。</para>
 
      <para>VPN の文書では、同じ ASCII
        アートを使うことがルールになっているので、
        この文書でも例外ではなく同様にアスキーアートを用います。</para>
 
      <para>ネットワークのトポロジは以下のようになります。</para>

      <screen>
Network #1            [ Internal Hosts ]    Private Net, 192.168.1.2-254
                      [   Win9x/NT/2K  ]
                      [      UNIX      ]
                               |
                               |
                        .---[fxp1]---.      Private IP, 192.168.1.1
                        |   FreeBSD  |
                        `---[fxp0]---'      Public IP, A.B.C.D
                               |
                               |
                      -=-=- Internet -=-=-
                               |
                               |
                        .---[fxp0]---.      Public IP, W.X.Y.Z
                        |   FreeBSD  |
                        `---[fxp1]---'      Private IP, 192.168.2.1
                               |
                               |
Network #2            [ Internal Hosts ]
                      [   Win9x/NT/2K  ]    Private Net, 192.168.2.2-254
                      [      UNIX      ]
      </screen>

      <para>ふたつのパブリック IP アドレスに注目してください。
	この文書では、これらの IP アドレスを参照する際には、
	これらの文字を用います。
	この文書の中で、これらの文字を見たら、
	あなた自身のパブリック IP アドレスに置き換えてください。
	内部では、2 つのゲートウェイコンピュータは、両方とも .1
	IP アドレスを持っています。そして、2 つのネットワークは、
	異なるプライベート IP アドレスを使っています
        (それぞれ <systemitem class="ipaddress">192.168.1.x</systemitem>
        および <systemitem class="ipaddress">192.168.2.x</systemitem>)。
	プライベートネットワークにあるすべてのコンピュータは、
	デフォルトゲートウェイとして、
	<systemitem class="ipaddress">.1</systemitem>
	コンピュータを使うように設定されています。</para>

      <para>意図していることは、ネットワークの観点から、
        各ネットワークは他のネットワークにあるコンピュータを、
	(時折パケットをドロップするようなややゆっくりなルータではありますが)
        同じルータに直接接続しているようにすることです。</para>

      <para>これは、たとえば、<systemitem
        class="ipaddress">192.168.1.20</systemitem> というコンピュータは、
        以下を実行できるということです。</para>
 
      <programlisting>ping 192.168.2.34</programlisting>
 
      <para>透過的にこれは動くはずです。
        &windows; コンピュータは、他のネットワークのコンピュータを、
	ローカルネットワークのコンピュータを見るのとまったく同じように、
        見ることができ、共有ファイルを見たりできます。</para>

      <para>すべてのことが安全に行われなければなりません。
        これは、2 つのネットワークの通信が暗号化されていなければならないことを意味しています。</para>

      <para>これらの 2 つのネットワーク間に VPN
        を構築するには複数のプロセスが必要となります。
        各ステージは以下のようになります。</para>

      <orderedlist>
        <listitem>
          <para>2 つのネットワーク間にインターネットを経由して、
	    <quote>virtual</quote>
	    ネットワークのリンクを作成します。
	    それが適切に動いていることを &man.ping.8;
	    のようなツールを使って、試験を行います。</para>
        </listitem>

        <listitem>
          <para>2 つのネットワーク間で、
	    必要に応じて透過的に暗号化、
	    復号化を保証するようにセキュリティポリシを適用します。
	    &man.tcpdump.1; のようなツールを使って、
	    通信が暗号化されていることを確認します。</para>
        </listitem>
        <listitem>
          <para>FreeBSD ゲートウェイにて、&windows; のコンピュータが VPN
	    を通して他のコンピュータを見ることができるように追加のソフトウェアを設定します。</para>
        </listitem>
      </orderedlist>

    <sect3>
      <title>ステップ 1: <quote>virtual</quote>
        ネットワークリンクの作成</title>

      <para>ネットワーク #1
        のゲートウェイコンピュータにログインしているとします。
        このコンピュータのパブリック IP アドレスは
	<systemitem class="ipaddress">A.B.C.D</systemitem>、
	プライベート IP アドレスは
	<systemitem class="ipaddress">192.168.1.1</systemitem> です。
	<systemitem class="ipaddress">W.X.Y.Z</systemitem>
	の IP アドレスのコンピュータのプライベートアドレスに対し
	<command>ping 192.168.2.1</command>
	を実行したとします。
        このコマンドが成功するには何が必要でしょうか？</para>

      <orderedlist>
        <listitem>
          <para>ゲートウェイコンピュータは、どのように
	    <systemitem class="ipaddress">192.168.2.1</systemitem>
	    に達するかを知っていなければなりません。
	    言い換えると、
	    <systemitem class="ipaddress">192.168.2.1</systemitem>
	    への経路を知っている必要があります。</para>
        </listitem>
        <listitem>
          <para>
	    <systemitem class="ipaddress">192.168.x</systemitem>
	    のような範囲のプライベート IP アドレスは広いインターネットでは、
	    使われることは想定されていません。
	    そのかわり、
	    <systemitem class="ipaddress">192.168.2.1</systemitem>
	    に送信した各パケットは、他のパケットに包れている必要があります。
	    このパケットは <systemitem class="ipaddress">A.B.C.D</systemitem>
	    から、
	    <systemitem class="ipaddress">W.X.Y.Z</systemitem>
	    へと送られる必要があります。
	    このプロセスは、
            <firstterm>カプセル化</firstterm>
	    と呼ばれます。</para>
        </listitem>
        <listitem>
          <para>このパケットが
	    <systemitem class="ipaddress">W.X.Y.Z</systemitem> に届くと、
            <quote>非カプセル化</quote> され、 
	    <systemitem class="ipaddress">192.168.2.1</systemitem>
	    に送信されます。</para>
        </listitem>
      </orderedlist>

      <para>これは、2 つのネットワーク間で、 <quote>tunnel</quote>
        が必要ということを示しています。二つの <quote>トンネルマウス</quote> は、
	IP アドレス
	<systemitem class="ipaddress">A.B.C.D</systemitem> と
	<systemitem class="ipaddress">W.X.Y.Z</systemitem>
	です。
	そして、トンネルは、これをパススルーすることを許容するプライベート
	IP アドレスのアドレスが指定されている必要があります。
	トンネルは、パブリックインターネットを経由して、
        プライベート IP アドレスで送信する時に使われます。</para>

      <para>このトンネルは、一般的なインタフェースもしくは、FreeBSD では
        gif デバイスで作成されます。
	想像通り、各ゲートウェイホストの gif
	インタフェースは、4 つの IP アドレスで設定されなくてはなりません。
        2 つはパブリック IP アドレスで、
        2 つはプライベートの IP アドレスです。</para>

      <para>両方の &os; カーネルで
        gif デバイスのサポートを組み入れてコンパイルする必要があります。
        以下の行を加えることで設定できます。</para>

      <programlisting>pseudo-device gif</programlisting>

      <para>両方のコンピュータのカーネルコンフィグレーションファイルに上記の行を加え、
        コンパイル、インストールし、通常通り再起動してください。</para>

      <para>トンネルの設定は 2 つのプロセスで行います。
        最初は、&man.gifconfig.8; を使って、
	外部 (パブリック) IP アドレスを設定するします。
	その後、プライベート IP アドレスを
	&man.ifconfig.8; を使って設定します。</para>

      <note>
	<para>&os;&nbsp;5.X では、
	  &man.gifconfig.8; ユーティリティが提供していた機能は、
	  &man.ifconfig.8; にマージされました。</para></note>

      <para>ネットワーク #1 にあるゲートウェイコンピュータで以下の
        2 つのコマンドを実行してトンネルを作成します。</para>
 
      <programlisting>gifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff
      </programlisting>

      <para>もう片方のゲートウェイコンピュータで、
        IP アドレスの順を逆にして同じコマンドを実行します。</para>
 
      <programlisting>gifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff
      </programlisting>

      <para>以下を実行して、設定を確認をしてください。</para>
 
      <programlisting>gifconfig gif0</programlisting>
 
      <para>たとえば、ネットワーク #1 のゲートウェイにおいては、
        以下のように確認できます。</para>
 
      <screen>&prompt.root; <userinput>gifconfig gif0</userinput>
gif0: flags=8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 --&gt; 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D --&gt; W.X.Y.Z
      </screen>

      <para>出力からわかるように、
	物理アドレス
	<systemitem class="ipaddress">A.B.C.D</systemitem> と
	<systemitem class="ipaddress">W.X.Y.Z</systemitem>
	の間にトンネルが作成され、
	<systemitem class="ipaddress">192.168.1.1</systemitem> と
	<systemitem class="ipaddress">192.168.2.1</systemitem>
	の間の通信がトンネルで許可されています。</para>
 
      <para>両方のコンピュータのルーティングテーブルにエントリが追加されました。
	<command>netstat -rn</command> で確認できます。
	ネットワーク #1
        のゲートウェイホストでの出力は以下のようになります。</para>
 
      <screen>&prompt.root; <userinput>netstat -rn</userinput>
Routing tables
 
Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...
      </screen>

      <para><quote>Flags</quote> の値が示すように、
	これはホストのルートで、
	各ゲートウェイは他のゲートウェイとどのように通信すれば良いかを知っていますが、
	他の関連するネットワークへの通信を知らないことを意味しています。
	この問題は、すぐに解決されます。</para>

      <para>両方のコンピュータでファイアウォールを設定していることがあります。
	VPN トラフィックのためには、ファイアウォールを迂回する必要があります。
	両方のネットワーク間のすべてのトラフィックを許可するか、VPN
        の末端をお互い保護するようなファイアウォールのルールを追加したいと思うでしょう。</para>

      <para>すべての VPN
        を経由するトラフィックを許容するようなファイアウォールを設定すると、
	テストを大きく簡略化できます。
	後でいつでも、セキュリティを強化できます。
	もし、ゲートウェイコンピュータで &man.ipfw.8; を用いているのであれば、
	以下のようなコマンドで、
        他のファイアウォールのルールに影響することなく、
        VPN の末端の間のトラフィックを許可します。</para>

      <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>

      <para>両方のゲートウェイコンピュータでこのコマンドを実行する必要があります。</para>

      <para>各ゲートウェイコンピュータで他のゲートウェイコンピュータに対して、
        ping を実行することができれば十分です。
	<systemitem class="ipaddress">192.168.1.1</systemitem>
	において、以下を実行が可能で</para>
 
      <programlisting>ping 192.168.2.1</programlisting>
 
      <para>そして、レスポンスを受け取れる必要があります。
        同じことを他のゲートウェイコンピュータで実行できる必要があります。</para>
 
      <para>しかしながら、各ネットワークの内部のコンピュータにアクセスはまだできません。
        これは、
	ゲートウェイコンピュータがお互いにアクセスする方法を知っているが、
        各ゲートウェイの奥にあるネットワークにアクセスする方法を知らないという、
	ルーティングに起因しています。</para>

      <para>この問題を解決するには、
        静的ルートを各ゲートウェイコンピュータに追加する必要があります。
        このために最初のゲートウェイで行うコマンドは以下のようになります。</para>

      <programlisting>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00
      </programlisting>

      <para>このコマンドの意味は、ネットワーク
	<quote><systemitem class="ipaddress">192.168.2.0</systemitem>
	のホストにアクセスするには、パケットを
	<systemitem class="ipaddress">192.168.2.1</systemitem>
	のホストに送る</quote> ことを意味しています。
	もう片方のゲートウェイでは、同様のコマンドを実行する必要があります。
	その場合には、かわりに、
	<systemitem class="ipaddress">192.168.1.x</systemitem>
	アドレスを使う必要があります。</para>

      <para>これで、片方のネットワーク上のホストからの IP トラフィックは、
	もう片方のネットワーク上のホストに届くようになります。</para>

      <para>2 つのネットワーク間の
	<quote>virtual</quote> および
	<quote>network</quote> について構築できたので、
	VPN について、2/3 が構築されました。残りは private です。
	&man.ping.8; および &man.tcpdump.1; を使って試験できます。
	ゲートウェイホストにログインして以下を実行してください。</para>
 
      <programlisting>tcpdump dst host 192.168.2.1</programlisting>

      <para>同じホストの他のログインセッションで、
        以下を実行してください。</para>

      <programlisting>ping 192.168.2.1</programlisting>

      <para>以下のような出力が表示されます。</para>
 
      <programlisting>
16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
      </programlisting>

      <para>この出力からわかるように、ICMP メッセージが戻り、
	復号化されます。
	&man.tcpdump.1; に <option>-s</option> パラメータを用いると、
	パケットから多くのデータを捕え、
	より多くの情報を得ることができます。</para>

      <para>明らかにこれは、受け入れられるものではありません。
	次の節では、2 つのネットワーク間のリンクについて、
        すべての通信が自動的に暗号化されるように安全にする方法について説明します。</para>

      <itemizedlist>
        <title>まとめ</title>
        <listitem>
          <para>両方のカーネルを <quote>pseudo-device
          gif</quote> で構築します。</para>
        </listitem>
        <listitem>
          <para>ゲートウェイホスト #1 の <filename>/etc/rc.conf</filename>
	    を編集して、以下の行を (必要に応じて IP アドレスを変更して)
	    追加します。</para>
          <programlisting>gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"
          </programlisting>
        </listitem>
        <listitem>
          <para>両方のホストのファイアウォールスクリプト
          (<filename>/etc/rc.firewall</filename> など)
	  を編集して以下を追加します。</para>

          <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
        </listitem>
        <listitem>
          <para>同様の変更を、ゲートウェイホスト #2 の
            <filename>/etc/rc.conf</filename>
	    においても行います。
	    ここで、IP アドレスの順番は逆にします。</para>
        </listitem>
      </itemizedlist>
    </sect3>

    <sect3>
      <title>ステップ 2: リンクを安全にする。</title>

      <para>リンクを安全にするために、IPsec を用います。
	IPsec は、2 つのホストが暗号鍵に合意し、
	その鍵を 2
        つのホストの間でデータを暗号化するのに用いるメカニズムを提供します。</para>

      <para>ここでは、設定を行う上で考慮すべき領域が 2 つあります。</para>

      <orderedlist>
        <listitem>
          <para>2 つのホストで、
	    用いる暗号メカニズムに合意するメカニズムが必要です。
	    2 つのホストが一度このメカニズムに合意したら、
	    これらの間で <quote>セキュリティアソシエーション</quote>
	    が確立されたことになります。</para>
        </listitem>
        <listitem>
          <para>どのトラフィックを暗号化するかを特定するメカニズムが必要となります。
            外向きのトラフィックのすべてを暗号化する必要はないのは明らかです。
	    -- VPN に関係するトラフィックのみを暗号化することが望まれます。
	    どのトラフィックを暗号すべきかを決めるために導入されるルールを
	    <quote>セキュリティポリシ</quote> と呼びます。</para>
         </listitem>
       </orderedlist>

       <para>セキュリティアソシエーションおよびセキュリティポリシの両方は、
         カーネルにより管理されています。そして、ユーザランドプログラムにより、
	 変更することができます。
	 しかしながら、これを行う前に、カーネルを IPsec および
	 Encapsulated Security Payload (ESP) プロトコルに対応するように、
	 設定する必要があります。
	 これは、カーネルを以下のように設定することで可能です。</para>

       <indexterm>
	 <primary>kernel options</primary>
	 <secondary>IPSEC</secondary>
       </indexterm>

       <programlisting>options IPSEC
options IPSEC_ESP
       </programlisting>

       <para>そして再構築し、再インストールを行って、再起動してください。
         これは両方のゲートウェイホストのカーネルで行う必要があります。</para>

       <indexterm>
	 <primary>IKE</primary>
       </indexterm>

       <para>セキュリティアソシエーションの設定に関していうと、
         2 つの選択肢があります。
         1 つ目は、2 つのホスト間の設定を手動で設定する方法で、
	 暗号アルゴリズム、暗号鍵などを選択する必要があります。
	 もう 1 つは、これらをあなたに代わり行う
	 Internet Key Exchange プロトコル (IKE)
	 を実装しているデーモンを用いることです。</para>

       <para>後者が推奨されます。とにかく、設定がより簡単です。</para>

       <indexterm>
	 <primary><command>setkey</command></primary>
       </indexterm>

       <para>&man.setkey.8; を用い得ることでセキュリティポリシを設定したり、
         表示できます。
         &man.route.8; がカーネルルーティングテーブルに関しているのと同様に、
         <command>setkey</command>
	 は、カーネルセキュリティポリシテーブルに関連しています。
	 <command>setkey</command> は、
	 現在のセキュリティアソシエーションも表示でき、
	 類推をさらに進めると、その点において、
         <command>netstat -r</command> と同種です。</para>

       <para>FreeBSD 
         でセキュリティアソシエーションを管理するデーモンは数多くあります。
         この文書では、その中の一つの racoon の使い方について説明します。
	 racoon は、&os; Ports Collection の
	 <filename role="package">security/racoon</filename>
	 からインストールできます。</para>

       <indexterm>
	 <primary>racoon</primary>
       </indexterm>

       <para>racoon は、両方のゲートウェイホストで実行される必要があります。
         それぞれのホストで、もう一つの VPN の端の IP アドレスおよび
	 (あなたが選択したもので、両方のゲートウェイで同じ必要のある)
	 秘密鍵で設定する必要があります。</para>

      <para>2 つのデーモンは、互いにコンタクトし、
	(設定した秘密鍵を用いて) だれが相手であるかを確認します。
	デーモンはその後、新しい秘密鍵を生成し、
	VPN 上のトラフィックの暗号化のために用います。
	攻撃者がこれらの鍵の (理論的には、不可能ですが)
	1 つをクラックしても、それ以上できないように、
	この秘密鍵を定期的に変更します。
	-- 彼らがカギをクラックしたときには、
	2 つのデーモンは他の鍵を選択していることでしょう。</para>

      <para>racoon's の設定は、
	<filename>${PREFIX}/etc/racoon</filename> で行われます。
	ここには、設定ファイルが置かれていますが、
	それほど多く変更する必要はありません。
	おそらくあなたが変更すべき racoon の設定の他の部分は、
	<quote>pre-shared key</quote> です。</para>

       <para>デフォルトの racoon の設定では、これは、
         <filename>${PREFIX}/etc/racoon/psk.txt</filename>
	 ファイルにあると仮定されています。
	 pre-shared key は、VPN リンクを経由するトラフィックの暗号化には、
	 <emphasis>用いられません</emphasis>。
         鍵管理デーモンがお互いを信頼するためのトークンです。</para>

       <para><filename>psk.txt</filename> は、
         あなたが取り扱う各リモートのサイトに関連する行を含んでいます。
         この例では、どこに 2 つのサイトがあるのか、
	 各 <filename>psk.txt</filename> ファイルは、一行を含んでいます
	 (なぜならば、各 VPN の端は、他の端のみを取り扱うため)。</para>
 
       <para>ゲートウェイホストの #1 では、
         この行は以下のようなものです。</para>
 
       <programlisting>W.X.Y.Z            secret</programlisting>

       <para>これは、リモート端の <emphasis>公開</emphasis> IP アドレス、空白、
         安全を提供するためのテキスト文字です。
         明らかに、<quote>secret</quote> をあなたの鍵に使うべきではありません。
         パスワードに対する通常の規則に従ってください。</para>
 
      <para>ゲートウェイホスト #2 では、この行は以下のようになります。</para>
 
      <programlisting>A.B.C.D            secret</programlisting>
 
      <para>これは、リモート端の公開 IP アドレスと先ほどと同じ秘密鍵です。
        racoon を実行する前に <filename>psk.txt</filename> のモードは、
	<literal>0600</literal>
	(i.e., <systemitem class="username">root</systemitem> のみが
	read/write できます) としてください。</para>

      <para>両方のホストゲートウェイコンピュータで racoon
        を走らせる必要があります。IKE
	トラフィックを許可するファイアウォールルールを追加する必要があります。
	IKE トラフィックは、UDP 上で ISAKMP (Internet Security Association
	Key Management Protocol) port に対して実行されるものです。
	このルールはファイアウォールルールセットの極めて最初に記述する必要があります。</para>
 
      <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
      </programlisting>
 
      <para>一度 racoon を走らせたら、
        片方のゲートウェイホストから、他のホストへ ping を実行できます。
	接続は、まだ暗号化されていませんが、racoon
	はその後 2 つのホスト間のセキュリティアソシエーションを設定します。
	これは時間を要し、
        ping コマンドが反応する前に少し時間の遅れとして認識できるでしょう。</para>

      <para>一度セキュリティアソシエーションが確立されたら、
        &man.setkey.8; を使って確認できます。
        どちらかのホストで以下のように実行して、
        セキュリティアソシエーション情報を確認してください。</para>

       <programlisting>setkey -D</programlisting>
 
       <para>以上で問題の半分が終わりました。
         もう半分は、セキュリティポリシの設定です。</para>
 
       <para>適切なセキュリティポリシを作成するには、
         これまでにどのように設定されているかを確認することが必要となります。
         この議論は、両方のリンクの端で行われます。</para>

       <para>送信された各 IP パケットには、ヘッダがあり、
         パケットに関するデータを持っています。
         ヘッダにはソースおよびデスティネーションの両方の
	 IP アドレスが含まれています。
	 我々はすでに知っているように、公開インターネット上では、
	<systemitem class="ipaddress">192.168.x.y</systemitem>
	 といった範囲のプライベート IP アドレスは使われません。
	 そのかわり、最初に他のパケット内にカプセル化されます。
	 このパケットは、プライベートアドレスのかわりに、
         公開ソースおよびデスティネーションの IP アドレスを持っています。</para>

       <para>そのため、外向きのパケットは以下のように始まります。</para>

       <screen>
  .----------------------.
  | Src: 192.168.1.1     |
  | Dst: 192.168.2.1     |
  | &lt;other header info&gt;  |
  +----------------------+
  | &lt;packet data&gt;        |
  `----------------------'</screen>

       <para>その後、他のパケットの中に以下のようにカプセル化されます。</para>

       <screen>
  .--------------------------.
  | Src: A.B.C.D             |
  | Dst: W.X.Y.Z             |
  | &lt;other header info&gt;      |
  +--------------------------+
  | .----------------------. |
  | | Src: 192.168.1.1     | |
  | | Dst: 192.168.2.1     | |
  | | &lt;other header info&gt;  | |
  | +----------------------+ |
  | | &lt;packet data&gt;        | |
  | `----------------------' |
  `--------------------------'</screen>

       <para>このカプセル化は gif
	 デバイスにより行われます。確認できるように、
         パケットは外側に本来の IP アドレスを持っており、
	 オリジナルパケットは、
         インターネットに外向きに送られるパケットの中にデータとしてラップされています。</para>

       <para>明らかに、VPN
         間のすべてのトラフィックが暗号化されることが必要となります。
	 言葉にすると以下のようになります。</para>

      <para><quote>もしパケットが 
	<systemitem class="ipaddress">A.B.C.D</systemitem>
	から、
	<systemitem class="ipaddress">W.X.Y.Z</systemitem>
	へと送られるとすると、
        必要なセキュリティアソシエーションを使って暗号化されます。</quote></para>

       <para><quote>もしパケットが、
         <systemitem class="ipaddress">W.X.Y.Z</systemitem>
         から届き、
	 <systemitem class="ipaddress">A.B.C.D</systemitem>
	 へと送られる場合には、
         必要なセキュリティアソシエーションを用いて復号化されます。</quote></para>

       <para>これは正解に近いのですが、極めて正しいというわけではありません。
         もしこれを行ったとすると、
         <systemitem class="ipaddress">W.X.Y.Z</systemitem>
	 へのトラフィック、または、ここからのトラフィックのすべてが、
	 VPN ではないトラックまで暗号化されてしまいます。
	 これはあなたが行いたいこととはまったく違います。
	 適切なポリシは以下のようなものになります。</para>

       <para><quote><systemitem class="ipaddress">A.B.C.D</systemitem>
	 からパケットが出たとして、
	 そのパケットが他のパケットをカプセル化し、
	 <systemitem class="ipaddress">W.X.Y.Z</systemitem>
	 へと送られるとすると、
         セキュリティアソシエーションを用いて暗号化します。</quote></para>

       <para><quote>もし、パケットが、<systemitem
           class="ipaddress">W.X.Y.Z</systemitem> から届き、
         そのパケットが他のパケットをカプセル化し、<systemitem
           class="ipaddress">A.B.C.D</systemitem> へと送られる場合には、
	 必要なセキュリティアソシエーションを使って復号化されます。</quote></para>

       <para>微妙な変更ですが、必要な変更です。</para>

       <para>セキュリティポリシは、同じく &man.setkey.8;
         を用いることで設定します。
         &man.setkey.8; は、ポリシを定義する設定言語の機能を持ちます。
	 stdin を使って設定の指示を行うか、設定の指示を含むファイル名を
	 <option>-f</option> に指定して使用します。</para>

       <para><systemitem class="ipaddress">W.X.Y.Z</systemitem>
	 向けへのすべてのトラフィックを暗号化するには、
	 ゲートウェイホスト #1 (パブリック IP アドレス
	 <systemitem class="ipaddress">A.B.C.D</systemitem>)
	 の設定は以下のようにしてください。</para>
 
       <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
       </programlisting>
 
       <para>これらのコマンドをファイル (たとえば
         <filename>/etc/ipsec.conf</filename>) に追加し、
         以下を実行してください。</para>

       <screen>&prompt.root; <userinput>setkey -f /etc/ipsec.conf</userinput></screen>

       <para><option>spdadd</option> は、&man.setkey.8; に対し、
         安全なポリシのデータベースにルールを追加することを伝えます。
	 この行の残りでは、どのパケットがこのポリシに一致するかを特定します。
	 <systemitem class="ipaddress">A.B.C.D/32</systemitem> および
	 <systemitem class="ipaddress">W.X.Y.Z/32</systemitem> は、
	 このポリシを適応したいネットワークを特定するための
	 IP アドレスとネットマスクです。
	 このケースでは、これらの 2
	 つのホスト間の通信に適応したいという例です。
         <option>ipencap</option> は、カーネルに対して、このポリシは、
	 他のパケットをカプセル化しているパケットのみに適応することを伝えます。
         <option>-P out</option> は、このポリシを外向きのパケットに適応し、
	 <option>ipsec</option> により、
         パケットが安全であることを伝えます。</para>

       <para>2 行目は、パケットをどのように暗号化するかを指定します。
         <option>esp</option> は使用するプロトコルで、
         <option>tunnel</option> は、IPsec
	 パケットにおいてさらにカプセル化されることを指定します。
	 <systemitem class="ipaddress">A.B.C.D</systemitem> および
	 <systemitem class="ipaddress">W.X.Y.Z</systemitem> は、
	 使用するセキュリティアソシエーションを選択するのに用います。
	 最後の <option>require</option> は、このルールにマッチした場合に、
	 パケットを暗号化することを指定します。</para>

       <para>このルールは、外向きのパケットのみにマッチします。
         同様のルールが内向きのパケットに対して必要です。</para>
 
       <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>

       <para>このケースでは、<option>out</option> のかわりに
         <option>in</option>、そして IP
         アドレスを逆にすることが必要です。</para>
 
       <para>(IP アドレス <systemitem class="ipaddress">W.X.Y.Z</systemitem>
         の) 他のゲートウェイホストにも同じルールが必要です。</para>
 
       <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>
 
       <para>最後に、ファイアウォールに ESP および IPENCAP
         パケットが行き来することを許可するルールを追加する必要があります。
         これらのルールは、
         それぞれのホストに追加する必要があります。</para>
 
       <programlisting>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
       </programlisting>
 
       <para>ルールは対称なので、
         それぞれのゲートウェイホストに同じルールを利用できます。</para>
 
       <para>外向きのパケットは、以下のようになります。</para>
 
       <screen>
  .------------------------------.  --------------------------.
  | Src: A.B.C.D                 |                            |
  | Dst: W.X.Y.Z                 |                            |
  | &lt;other header info&gt;          |                            |  Encrypted
  +------------------------------+                            |  packet.
  | .--------------------------. |  -------------.            |  contents
  | | Src: A.B.C.D             | |               |            |  are
  | | Dst: W.X.Y.Z             | |               |            |  completely
  | | &lt;other header info&gt;      | |               |            |- secure
  | +--------------------------+ |               |  Encap'd   |  from third
  | | .----------------------. | |  -.           |  packet    |  party
  | | | Src: 192.168.1.1     | | |   |  Original |- with real |  snooping
  | | | Dst: 192.168.2.1     | | |   |  packet,  |  IP addr   |
  | | | &lt;other header info&gt;  | | |   |- private  |            |
  | | +----------------------+ | |   |  IP addr  |            |
  | | | &lt;packet data&gt;        | | |   |           |            |
  | | `----------------------' | |  -'           |            |
  | `--------------------------' |  -------------'            |
  `------------------------------'  --------------------------'
       </screen>

       <para>VPN の端から受け取った場合には、
         (racoon によりネゴシエートされたセキュリティアソシエーションを用いて)
	 最初に復号化を行います。
         その後、gif インタフェースに入ります。
	 このインタフェースは、内部のネットワークを回ることのできる最も内側のパケットになるまで、セカンドレイヤのラップをはがします。</para>

       <para>先ほどと同じく &man.ping.8; 試験でセキュリティを確認できます。
         最初に、<systemitem class="ipaddress">A.B.C.D</systemitem>
	 ゲートウェイコンピュータにログインして、
         以下を実行してください。</para>

       <programlisting>tcpdump dst host 192.168.2.1</programlisting>

       <para>同じホストの別のログインセッションで以下を実行してください。</para>
       <programlisting>ping 192.168.2.1</programlisting>

       <para>今回は、以下のような出力が表示されます。</para>
 
       <programlisting>XXX tcpdump output</programlisting>
 
       <para>&man.tcpdump.1; は、ESP パケットを表示します。
         <option>-s</option> オプションを使って実行すると、
         暗号化のため、見ても理解できないものが表示されるでしょう。</para>

      <para>おめでとうございます。
        これで 2 つのリモートサイト間の VPN を設定できました。</para>
 
      <itemizedlist>
        <title>まとめ</title>
        <listitem>
          <para>以下のオプションでカーネルを再構築します。</para>
 
          <programlisting>options IPSEC
options IPSEC_ESP
          </programlisting>
        </listitem>
        <listitem>
          <para><filename
            role="package">security/racoon</filename> をインストールします。
	    両方のゲートウェイホストにおいて、
            <filename>${PREFIX}/etc/racoon/psk.txt</filename> を変更して、
	    リモートホストの IP
	    アドレスのエントリおよびお互いが知っている秘密鍵を追加してください。
	    このファイルのモードは 0600 に設定してください。</para>
        </listitem>
        <listitem>
          <para>各ホストにおいて以下の行を
            <filename>/etc/rc.conf</filename> に追加してください。</para>
 
          <programlisting>ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"
          </programlisting>
        </listitem>
        <listitem>
          <para>各ホストにおいて <filename>/etc/ipsec.conf</filename>
	    を作成し、必要となる spdadd 行を追加してください。
	    ゲートウェイホスト #1 では以下のようになります。</para>
 
          <programlisting>
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
</programlisting>
 
          <para>ゲートウェイホスト 2 では以下のようになります。</para>
 
<programlisting>
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
</programlisting>
        </listitem>
        <listitem>
          <para>両方のホストにおいて IKE, ESP, および IPENCAP
	    トラフィックが許可されるようにファイアウォールのルールを追加してください。</para>
 
          <programlisting>
ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
          </programlisting>
        </listitem>
      </itemizedlist>

      <para>直前の 2 つのステップは、VPN を実行できれば十分です。
        各ネットワークのコンピュータは、IP
	アドレスを使って他のネットワークのコンピュータを参照できますし、
	すべてのリンクを横切るトラフィックは自動的にそして安全に暗号化されます。</para>
    </sect3>
    </sect2>
 </sect1>

  <sect1 xml:id="openssh">
    <info><title>OpenSSH</title>
      <authorgroup>
	<author><personname><firstname>Chern</firstname><surname>Lee</surname></personname><contrib>寄稿: </contrib></author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </info>

    
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>セキュリティ</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application>
      はリモートマシンへのセキュアなアクセスに使われるネットワーク接続ツールの集合です。
      これは <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command>,
      <command>telnet</command> をそのまま置き換えて使えます。
      また、他のあらゆる TCP/IP 接続を
      SSH 経由でセキュアにトンネル/フォワードすることもできます。
      <application>OpenSSH</application> はすべてのトラフィックを暗号化し、
      盗聴や接続の乗っ取り等のネットワークレベルの攻撃を事実上無効化します。</para>

    <para><application>OpenSSH</application>
      は OpenBSD プロジェクトによって維持管理されており、SSH v1.2.12
      に最新のすべてのバグ修正と更新を適用したものをベースにしています。
      <application>OpenSSH</application> クライアントは SSH プロトコル 1 と 2 の両方に互換性があります。
      <application>OpenSSH</application> は FreeBSD&nbsp;4.0 以降ベースシステムに取り込まれています。</para>

    <sect2>
      <title>OpenSSH を使うことの利点</title>

      <para>&man.telnet.1; や &man.rlogin.1;
	を使う場合、一般にデータはネットワークを平文で流れます。
	ネットワークをクライアントとサーバの間のどこかで盗聴することで
	あなたのユーザ/パスワード情報やセション中を流れるデータを盗むことが可能です。
	<application>OpenSSH</application>
	はこれらを予防する為にさまざまな認証と暗号化の方法を提供します。</para>
    </sect2>

    <sect2>
      <title>sshd を有効にする</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>有効化</secondary>
      </indexterm>

      <para><filename>rc.conf</filename> ファイルに
	以下の行を追加してください。</para>

      <screen>sshd_enable="YES"</screen>

      <para>次に起動したときから
	<application>OpenSSH</application> のデーモンプログラムである
	&man.sshd.8; が起動します。
	もしくはコマンドラインから単に <command>sshd</command>
	と入力して、直接 <application>sshd</application>
	デーモンを実行しても構いません。</para>
    </sect2>

    <sect2>
      <title>SSH クライアント</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>クライアント</secondary>
      </indexterm>

      <para>&man.ssh.1; ユーティリティは
	&man.rlogin.1; と同様に働きます。</para>

      <screen>&prompt.root; <userinput>ssh user@example.com</userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>ログインは <command>rlogin</command> や <command>telnet</command>
	でセッションを張った時と同様に続きます。
	SSH はクライアントが接続した時、
	サーバの信頼性の検証のために鍵指紋システム
	(key fingerprint system) を利用します。
	初めての接続の際にのみ、ユーザは <literal>yes</literal> と入力することを要求されます。
	これ以降の login では保存されていた鍵指紋を照合することで検証されます。
	SSH クライアントは保存されていた鍵指紋が
	login しようとした際に送られてきたものと異なっていた場合には警告を表示します。
	指紋は <filename>~/.ssh/known_hosts</filename> に、また
	SSH v2 指紋の場合は <filename>~/.ssh/known_hosts2</filename>
	に保存されます。</para>

      <para>デフォルトでは、<application>OpenSSH</application>
	サーバは SSH v2	のみの接続を受け付けるように設定されています。
	クライアントはバージョン 1 および 2 のどちらかを選択できます。
	バージョン 2 は、旧バージョンよりも堅固で安全です。</para>

      <para>&man.ssh.1; コマンドに、プロトコル v1 と v2
	についてそれぞれ、引数 <option>-1</option> または <option>-2</option>
	を渡すことで、利用するプロトコルを強制できます。</para>
    </sect2>

    <sect2>
      <title>Secure copy</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>&man.scp.1; コマンドは
	&man.rcp.1; と同様に働きます。
	安全な方法で行っているほかは、ローカルのファイルをリモートマシンへ、
	あるいはリモートマシンのファイルをローカルにコピーするのは同じです。</para>

      <screen>&prompt.root; <userinput> scp user@example.com:/COPYRIGHT COPYRIGHT</userinput>
user@example.com's password: <userinput>*******</userinput>
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>前回の例でこのホストの指紋がすでに保存されていれば
	この &man.scp.1; を使う時に検証が行なわれます。</para>

      <para>&man.scp.1; に渡される引数は、&man.cp.1;
	のものと似ており、ファイル (1 つまたは複数) が
	1 つめの引数になり、コピー先が 2 つめの引数になります。
	ファイルはネットワーク越しに SSH を通して送られるので、
	引数に指定するファイルには
	<option>user@host:&lt;path_to_remote_file&gt;</option>
	という形式をとるものがあります。</para>
    </sect2>

    <sect2>
      <title>設定</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>設定</secondary>
      </indexterm>

      <para>システム全体の設定ファイルは、<application>OpenSSH</application>
	デーモン、クライアントの両方とも <filename>/etc/ssh</filename>
	ディレクトリにあります。</para>

      <para><filename>ssh_config</filename> はクライアントの動作設定、
	<filename>sshd_config</filename>
	はデーモンの動作設定を行ないます。</para>

      <para>さらに、<filename>rc.conf</filename> オプションの
	<option>sshd_program</option>
	(デフォルトは <filename>/usr/sbin/sshd</filename>) と
	<option>sshd_flags</option>
	により、詳細な設定が行えます。</para>
    </sect2>

    <sect2>
      <title>ssh-keygen</title>

      <para>パスワードの代わりに &man.ssh-keygen.1;
	を使ってユーザの認証用の RSA 暗号鍵を作ることができます。</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>rsa1</replaceable></userinput>
Initializing random number generator...
Generating p:  .++ (distance 66)
Generating q:  ..............................++ (distance 498)
Computing the keys...
Key generation complete.
Enter file in which to save the key (/home/user/.ssh/identity):
Enter passphrase:
Enter the same passphrase again:
Your identification has been saved in /home/user/.ssh/identity.
...</screen>

      <para>&man.ssh-keygen.1; は認証に使う為の公開鍵と秘密鍵のペアを作ります。
	秘密鍵は <filename>~/.ssh/identity</filename> に保存され、
	公開鍵は <filename>~/.ssh/identity.pub</filename> に保存されます。
	公開鍵はリモートマシンの <filename>~/.ssh/authorized_keys</filename>
	にも置かなければなりません。</para>

      <para>これでパスワードの代わり
	RSA 認証を使ってリモートマシンに接続できるようになったはずです。</para>

      <note><para>The <option>-t rsa1</option> オプションは、
	SSH プロトコルバージョン 1 で用いられる RSA 鍵を生成します。
	SSH プロトコルバージョン 2 で用いられる RSA 鍵を生成するには、
	<command>ssh-keygen -t rsa</command> を実行してください。</para></note>

      <para>&man.ssh-keygen.1; でパスフレーズを使っている場合は、
	ユーザは秘密鍵を使うために毎回パスフレーズの入力を行なう必要があります。</para>

      <para>同じ目的で、<command>ssh-keygen -t dsa</command>
	コマンドを使って SSH プロトコルバージョン 2 の
	DSA 鍵を生成することもできます。
	これは、SSH プロトコルバージョン 2 セッション専用の DSA 公開/秘密鍵を生成します。
	公開鍵は <filename>~/.ssh/id_dsa.pub</filename>
	に保存され、秘密鍵は <filename>~/.ssh/id_dsa</filename>
	に置かれます。</para>

      <para>DSA 公開鍵についても同様にリモートマシンの
	<filename>~/.ssh/authorized_keys</filename>
	内におきます。</para>

      <para>&man.ssh-agent.1; と &man.ssh-add.1; は
	複数のパスワード化された秘密鍵の管理に使われます。</para>

      <warning><para>システムにインストールされている
	<application>OpenSSH</application> のバージョンによって、
	オプションやファイルに違いが出てくることがあります。
	&man.ssh-keygen.1; を参照して、問題が起こることを避けてください。</para></warning>
    </sect2>

    <sect2 xml:id="security-ssh-tunneling">
      <title>SSH トンネリング</title>
      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>トンネリング</secondary>
      </indexterm>

      <para><application>OpenSSH</application> は暗号化されたセッションの中に他のプロトコルを
	カプセル化するトンネルを作ることができます。</para>

      <para>以下のコマンドは &man.ssh.1; で <application>telnet</application>
	用のトンネルを作成します。</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L 5023:localhost:23 user@foo.example.com</userinput>
&prompt.user;</screen>

      <para><command>ssh</command> コマンドは、
	次のオプションとともに利用します。</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para><command>ssh</command> にプロトコルバージョン 2
	      を使うことを指示します。(古い SSH
	      サーバを使っているときには指定しないでください)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>はトンネルだけでコマンドはないことを示します。
	      省略されると &man.ssh.1; は通常のセッションを開始します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para><command>ssh</command>
	      にバックグラウンド実行を強制します。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>ローカルトンネルを
	      <replaceable>localport:remotehost:remoteport</replaceable>
	      という形式で指定します。</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>リモートの SSH サーバです。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>SSH のトンネルは <systemitem>localhost</systemitem>
	の指定されたポートに listen
	するソケットを作ることで実現されています。
	SSH はローカルのホスト/ポートで受けた接続すべてを SSH
	接続経由で指定されたリモートホストのポートへ転送します。</para>

      <para>この例では、<systemitem>localhost</systemitem> のポート
	<replaceable>5023</replaceable>	がリモートマシンの
	<systemitem>localhost</systemitem> のポート <replaceable>23</replaceable>
	に転送されるようになっています。
 	<replaceable>23</replaceable> は <application>telnet</application> なのでこれは SSH
 	トンネルを通るセキュアな <application>telnet</application> セッションを作ります。</para>

      <para>このようにして SMTP や POP3, FTP 等のセキュアではない TCP
	プロトコルをカプセル化することができます。</para>

      <example>
	<title>SSH を用いた SMTP 用の安全なトンネルの作成</title>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L 5025:localhost:25 user@mailserver.example.com</userinput>

user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	<para>&man.ssh-keygen.1;
	  と別のユーザアカウントを組み合わせて使うことでより透過的で悩まずに済むような
	  SSH のトンネル環境を作ることができます。
	  パスワードを入力するところで暗号鍵を使い、
	  トンネルは別のユーザ権限で実行することが可能です。</para>
      </example>

      <sect3>
	<title>実用的な SSH トンネルの例</title>

	<sect4>
	  <title>POP3 サーバへの安全な接続</title>

	  <para>仕事で、外部からの接続を受ける SSH サーバがあるとします。
	    同じオフィスのネットワークには、POP3
	    サーバが動いているメールサーバがあるとします。
	    ネットワークもしくはあなたの家とオフィスの間のネットワーク経路は、
	    完全に信頼できるものかもしれませんし、そうではないかもしれません。
	    そのため、電子メールは安全なやり方で見るようにしなければなりません。
	    解決策は、オフィスの SSH サーバへの SSH 接続を行い、
	    メールサーバへのトンネルを作成することです。</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com</userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>トンネルが作成されて動作したら、
	    メールクライアントに対し <systemitem>localhost</systemitem>
	    のポート 2110 に POP3 リクエストを送るように指示できます。
	    そこへの接続は、トンネルを経由して安全に
	    <systemitem>mail.example.com</systemitem> に転送されます。</para>
	</sect4>

	<sect4>
	  <title>厳格なファイアウォールをすり抜ける</title>

	  <para>内向けの接続をフィルタするだけでなく、
	    外向けの接続もフィルタして、
	    極端に厳しいファイアウォールルールを課すネットワーク管理者もいます。
	    リモートのマシンには、SSH 接続と web サーフィンのための
	    22 番および 80 番ポートにしか接続させてもらえないかもしれません。</para>

	  <para>あなたは、それ以外の (もしかすると仕事に関係ない)
	    サービスにアクセスしたくなるかもしれません。
	    例えば、音楽ストリーミングを行う
	    Ogg Vorbis サーバといったものです。
	    この Ogg Vorbis サーバが 22 番または
	    80 番ポート以外でストリーミングを行っていたら、
	    あなたはそのサーバに接続できないでしょう。</para>

	  <para>それに対する解決策は、
	    あなたが接続しているネットワークのファイアウォールの外部にあるマシンに対して
	    SSH 接続を行い、Ogg Vorbis
	    サーバへのトンネルに利用することです。</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>ストリーミングクライアントを <systemitem>localhost</systemitem>
	    の 8888 番ポートに向けると、<systemitem>music.example.com</systemitem>
	    の 8000 番ポートに転送され、
	    ファイアウォールをすり抜けられます。</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title><varname>AllowUsers</varname> ユーザオプション</title>

      <para>ログインできるユーザや接続元を制限することは、
        通常は良い考えです。
        <literal>AllowUsers</literal> オプションは、
	この目的のために使うことができます。
        たとえば、
	<systemitem class="username">root</systemitem> ユーザが
	<systemitem class="ipaddress">192.168.1.32</systemitem>
	からのみログインできるようにするには、
        <filename>/etc/ssh/sshd_config</filename>
	ファイルの設定は以下のようになります。</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para><systemitem class="username">admin</systemitem>
	ユーザがどこからでもログインできるようにするには、
	ユーザ名そのものを記述してください。</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>複数のユーザは、以下のように同じ行に追加してください。</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
        <para>注意すべきことは、
	  このコンピュータにログインする必要のあるすべてのユーザを指定することです。
	  設定されていないと、そのユーザはログインできなくなります。</para>
      </note>

      <para><filename>/etc/ssh/sshd_config</filename> への変更が終わったら、
	以下を実行して、設定ファイルを &man.sshd.8;
	に読み込ませてください。</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>もっと詳しく知りたい人へ</title>

      <para><link xlink:href="http://www.openssh.com/">OpenSSH</link></para>

      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
        &man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5;</para>

      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5;</para>
    </sect2>
  </sect1>

  <sect1 xml:id="fs-acl">
    <info><title>ファイルシステムアクセス制御リスト</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>寄稿: </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>ACL</primary>
    </indexterm>

    <para>スナップショットのようなファイルシステムの拡張と連携して、
      FreeBSD 5.0 以降ではファイルシステムアクセス制御リスト
      (<acronym>ACLs</acronym>) によるセキュリティを提供しています。</para>

    <para>アクセス制御リストは、標準的な &unix; のパーミッションモデルを、
      非常に互換性の高い (&posix;.1e) やり方で拡張しています。
      この機能は、管理者がより洗練されたセキュリティモデルを利用し、
      その恩恵を受けられるようにします。</para>

    <para><acronym>UFS</acronym> ファイルシステム用の
      <acronym>ACL</acronym> サポートを有効にするには、
      次のオプションをカーネルに組み込まなければなりません。</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>もしこのオプションが組み込まれていなければ、<acronym>ACLs</acronym>
      に対応したファイルシステムをマウントしようとすると、
      警告が表示されます。このオプションは <filename>GENERIC</filename>
      カーネルに含まれています。<acronym>ACLs</acronym>
      は、ファイルシステムの拡張属性が有効になっていることに依存しています。
      拡張属性は、次世代 &unix; ファイルシステムである <acronym>UFS2</acronym>
      でネイティブ対応されています。</para>

    <note><para><acronym>UFS1</acronym> に拡張属性を付すように設定するのは、
      <acronym>UFS2</acronym>
      よりも高いレベルの管理オーバヘッドが必要になります。
      また、<acronym>UFS2</acronym>
      における拡張属性のパフォーマンスも大きく上がっています。
      その結果、アクセス制御リストを利用する上では、一般的には
      <acronym>UFS1</acronym> よりも <acronym>UFS2</acronym>
      の方がおすすめです。</para></note>

    <para><acronym>ACLs</acronym> は、マウント時の管理フラグ
      <option>acls</option> で有効にされます。
      これは <filename>/etc/fstab</filename> に記述できます。
      マウント時のフラグは、&man.tunefs.8;
      を使って、ファイルシステムヘッダのスーパブロックにある
      <acronym>ACLs</acronym> フラグを変更するという方法で、
      常に自動で設定されるようになります。一般的には、
      下記の理由からスーパブロックフラグを使う方がよいでしょう。</para>

    <itemizedlist>
      <listitem>
	<para>マウント時に指定した <acronym>ACLs</acronym> フラグは再マウント
	  (&man.mount.8; <option>-u</option>) 時に変更できません。完全に
	  &man.umount.8; した上で、新たに &man.mount.8;
	  するしかありません。これは、起動後にルートファイルシステムで
	  <acronym>ACLs</acronym> を有効にできないことを意味します。
	  また、ファイルシステムを利用し始めた後では、
	  その配列を変えられないことも意味しています。</para>
      </listitem>

      <listitem>
	<para>スーパブロックフラグを設定すると、<filename>fstab</filename>
	  に記述されていなかったり、デバイスの順番が変わってしまっても、常に
	  <acronym>ACLs</acronym> が有効な状態でマウントされます。
	  こうすることで、ファイルシステムを <acronym>ACLs</acronym>
	  を有効にしないままマウントしてしまい、<acronym>ACLs</acronym>
	  が正しくないかたちで強制され、
	  セキュリティ問題につながることを防ぎます。</para>
      </listitem>
    </itemizedlist>

    <note><para><acronym>ACLs</acronym> の動作を変更して、まったく新たに
      &man.mount.8;
      を行わなくてもフラグを有効にできるようにすることも可能でしょう。
      しかし、我々は、うっかり <acronym>ACLs</acronym>
      を有効にしないでマウントしてしまうのを防ぐようにした方が望ましいと考えました。
      <acronym>ACLs</acronym> を有効にし、その後無効にしてから、
      拡張属性を取り消さないでまた有効にしてしまうと、
      鬱陶しい状態に自分で入り込んでしまえるからです。
      一般的には、一度ファイルシステムで <acronym>ACLs</acronym>
      を有効にしたら、無効にすべきではありません。そうしてしまうと、
      ファイル保護がシステムのユーザの意図と齟齬をきたす可能性があるばかりか、
      <acronym>ACLs</acronym> を再度有効にすると、
      それまでパーミッションが変更されてきたファイルに古い
      <acronym>ACLs</acronym> を割り当ててしまい、
      予想しない動作につながることも考えられます。</para></note>

    <para><acronym>ACLs</acronym> を有効にしたファイルシステムは、
      パーミッション設定の表示に <literal>+</literal> (プラス)
      記号がつきます。例えば、次のようになります。</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>ここでは、ディレクトリ <filename>directory1</filename>,
      <filename>directory2</filename> および <filename>directory3</filename>
      のすべてで <acronym>ACLs</acronym> が働いています。
      ディレクトリ <filename>public_html</filename> は対象外です。</para>

    <sect2>
      <title><acronym>ACL</acronym> を利用する</title>

      <para>&man.getfacl.1; ユーティリティは、
	ファイルシステムの <acronym>ACL</acronym> を表示します。
	たとえば、<filename>test</filename> ファイルの
	<acronym>ACL</acronym> 設定を表示するには、
	以下のコマンドを実行してください。</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>このファイルの <acronym>ACL</acronym> 設定を変更するには、
	以下のように &man.setfacl.1;
	ユーティリティを使用してください。</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para><option>-k</option> フラグは、
	ファイルまたはファイルシステムから、現在設定されている
	<acronym>ACL</acronym> をすべて取り除きます。
	より好ましい方法は、
	<option>-b</option> を使う方法です。
	このオプションを使うと、<acronym>ACL</acronym>
	が動作するのに必要な基本のフィールドは残ります。</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,group:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>上記のコマンドにおいて、<option>-m</option>
	オプションは、デフォルト <acronym>ACL</acronym>
	エントリを修正するために使われています。
	先ほどのコマンドで設定は削除されたため、
	定義されたエントリはありません。
	このコマンドは、デフォルトオプションに戻し、
	指定したオプションを割り当てます。
	システムに存在しないユーザまたはグループを追加すると、
	<errorname>Invalid argument</errorname> エラーが
	<filename>stdout</filename>
	に出力されることに気を付けてください。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-portaudit">
    <info><title>サードパーティ製ソフトウェアのセキュリティ問題を監視する</title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Portaudit</primary>
    </indexterm>

    <para>近年、セキュリティの分野では、
      脆弱性の評価方法に関して多くの改善が行わています。
      今日ではどのオペレーティングシステムにおいても、
      システムへの侵入の脅威は、
      サードパーティ製ユーティリティをインストールし、
      設定するほどに増加していきます。</para>

    <para>脆弱性を評価することは、セキュリティにおいて主要な要素です。
      &os; は、ベースシステムに対して勧告を発行していますが、
      すべてのサードパーティ製ユーティリティに対して勧告を発行することは、
      &os; プロジェクトの能力を超えています。
      サードパーティ製ユーティリティに関わる脆弱性を軽減し、
      管理者に対し、既知のセキュリティ問題について警告する方法が存在します。
      &os; には、<application>Portaudit</application>
      と呼ばれる追加のユーティリティが、
      この目的のために用意されています。</para>

    <para><filename role="package">security/portaudit</filename> port は、
      &os; セキュリティチームおよび ports
      開発者がアップデートし、管理している、
      既知のセキュリティ問題に対するデータベースを入手します。</para>

    <para><application>Portaudit</application> を使うには、
      Ports Collection からインストールしてください。</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/security/portaudit &amp;&amp; make install clean</userinput></screen>

    <para>インストールの過程で、
      &man.periodic.8; の設定ファイルはアップデートされ、
      毎日のセキュリティに関するスクリプトの実行中において
      <application>Portaudit</application>
      による出力が行われるようになります。
      毎日のセキュリティに関するスクリプトの実行結果のメールが読めることを確認してください。
      このメールは、<systemitem class="username">root</systemitem>
      アカウントに送られます。
      この時点では、設定は必要ありません。</para>

    <para>インストールが終わったら、管理者は以下のコマンドを実行して、
      <filename class="directory">/var/db/portaudit</filename>
      にローカルで保存されているデータベースをアップデートする必要があります。</para>

    <screen>&prompt.root; <userinput>portaudit -F</userinput></screen>

    <note>
      <para>データベースは、
	&man.periodic.8; の実行中に自動的にアップデートされるので、
	先のコマンドを実行することは完全に任意です。
	以下の説明のためだけに必要です。</para>
    </note>

    <para>Ports Collection
      からインストールされたサードパーティ製ユーティリティを監査するためには、
      管理者は以下のコマンドだけを実行する必要があります。</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para>以下は出力の例です。</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>表示されている <acronym>URL</acronym>
      をウェブブラウザで開くと、管理者は、
      問題となっている脆弱性についてより多くの情報を得ることができます。
      ここでの出力では、影響するバージョンが
      &os; Port バージョンにより示され、
      セキュリティ勧告を含む他のウェブサイトが含まれています。</para>

    <para>一口にいうと、<application>Portaudit</application> は強力で、
      <application>Portupgrade</application> port
      と共に使うときわめて有用なユーティリティです。</para>
  </sect1>

  <sect1 xml:id="security-advisories">
    <info><title>&os; セキュリティ勧告</title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>FreeBSD セキュリティ勧告</primary>
    </indexterm>

    <para>多くの高品質なオペレーティングシステムと同様、
      &os; は <quote>セキュリティ勧告</quote> を発行しています。
      これらの勧告は、通常セキュリティに関連したのメーリングリストに投稿され、
      サポートされているリリースに対してパッチが作成された後、
      Errata に記載されます。
      この章では、セキュリティ勧告とは何か、どのように理解すべきか、
      システムにパッチを当てるにはどのように対応すればよいかについて説明します。</para>

    <sect2>
      <title>セキュリティ勧告はどのようなものか？</title>

      <para>&os; セキュリティ勧告は、以下のようなものです。
	以下は &a.security-notifications.name;
	メーリングリストに流れたものです。</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co xml:id="co-topic"/>

Category:       core<co xml:id="co-category"/>
Module:         sys<co xml:id="co-module"/>
Announced:      2003-09-23<co xml:id="co-announce"/>
Credits:        Person@EMAIL-ADDRESS<co xml:id="co-credit"/>
Affects:        All releases of &os;<co xml:id="co-affects"/>
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co xml:id="co-corrected"/>
&os; only:   NO<co xml:id="co-only"/>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co xml:id="co-backround"/>


II.  Problem Description<co xml:id="co-descript"/>


III. Impact<co xml:id="co-impact"/>


IV.  Workaround<co xml:id="co-workaround"/>


V.   Solution<co xml:id="co-solution"/>


VI.  Correction details<co xml:id="co-details"/>


VII. References<co xml:id="co-ref"/></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para><literal>Topic</literal> フィールドは、何が問題であるかを正確に示しています。
	    通常は、このセキュリティ勧告の導入部であり、
	    脆弱性のあるユーティリティを示します。</para>
	</callout>

	<callout arearefs="co-category">
	  <para><literal>Category</literal> フィールドでは、
	    脆弱性がシステムのどの部分に影響するかを示します。
	    <literal>core</literal>, <literal>contrib</literal>
	    または <literal>ports</literal> のどれかが示されます。
	    <literal>core</literal> カテゴリは、
	    &os; オペレーティングシステムの <literal>core</literal>
	    コンポーネントに影響する脆弱性であることを意味します。
	    <literal>contrib</literal> カテゴリは、
	    <application>sendmail</application>
	    のように、&os; の外で開発され、&os;
	    プロジェクトに取り込まれたソフトウェアに影響する脆弱性であることを意味します。
	    <literal>ports</literal> カテゴリは、Ports Collection として、
	    インストールされるソフトウェアに影響する脆弱性であることを示しています。</para>
	</callout>

	<callout arearefs="co-module">
	  <para><literal>Module</literal> フィールドは、
	    (たとえば <literal>sys</literal> といった)
	    影響するコンポーネントを参照します。
	    この場合、<literal>sys</literal>
	    モジュールに影響することがわかります。
	    そのため、この脆弱性は、
	    カーネルの中で使われるコンポーネントに影響します。</para>
	</callout>

	<callout arearefs="co-announce">
	  <para><literal>Announced</literal> フィールドは、
	    セキュリティ勧告が発行された日、
	    またはアナウンスされた日が記載されています。
	    セキュリティチームによりこの問題が存在することが確認され、
	    パッチが &os;
	    ソースコードリポジトリにコミットされたことを意味します。</para>
	</callout>

	<callout arearefs="co-credit">
	  <para><literal>Credits</literal> フィールドは、 
	    脆弱性を通知し、報告した個人または組織を示します。</para>
	</callout>

	<callout arearefs="co-affects">
	  <para><literal>Affects</literal> フィールドは、この脆弱性がどの
	    &os; リリースに影響するかを説明します。
	    カーネルでは、影響するファイルに対して
	    <command>ident</command> を実行すると、
	    その出力からリビジョンを簡単に確認できます。
	    ports の場合には、<filename>/var/db/pkg</filename>
	    の port の名前の後に、バージョン番号が示されています。
	    もし、システムが &os; <acronym>CVS</acronym>
	    リポジトリと同期し、再構築が毎日行われているような状況でなければ、
	    おそらく、そのシステムには影響しているでしょう。</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para><literal>Corrected</literal> フィールドは、
	    脆弱性が修正された日、時間、
	    タイムゾーン、およびリリースが示されます。</para>
	</callout>

	<callout arearefs="co-only">
	  <para><literal>&os; only</literal> フィールドは、
	    この脆弱性が、&os; にのみ影響するか、もしくは、
	    他のオペレーティングシステムにも同様に影響するかどうかを示します。</para>
	</callout>

	<callout arearefs="co-backround">
	  <para><literal>Background</literal> フィールドは、
	    影響しているユーティリティがどのようなものであるかといった情報を正確に示します。
	    大体の場合は、なぜユーティリティが &os; に存在するか、
	    何のために使われているか、
	    どのように用いられるようになってきたか、
	    といった情報が示されます。</para>
	</callout>

	<callout arearefs="co-descript">
	  <para><literal>Problem Description</literal> フィールドは、
	    より深くセキュリティホールについて説明します。
	    問題のあるコードの情報や、
	    このユーティリティが悪意のある使い方により、
	    どのようにセキュリティホールを開けうるかといったことが示されます。</para>
	</callout>

	<callout arearefs="co-impact">
	  <para><literal>Impact</literal> フィールドは、
	    この問題がシステムに対して、
	    どのような形式の影響を与えるかについて示します。
	    たとえば、DoS 攻撃によるものか、
	    ユーザに対して意図しない特権を持たせてしまうものか、
	    または、攻撃者にスーパユーザのアクセスを与えるようなものか、
	    といったことが示されます。</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para><literal>Workaround</literal> フィールドは、
	    システムをアップグレードできないシステム管理者に対して、
	    実現可能な回避方法を提供します。
	    これは、時間による制限や、ネットワークの可用性、
	    他のたくさんの理由によります。
	    このような理由にかかわらず、
	    セキュリティを甘く見るべきではありません。
	    影響するシステムは、パッチが当てられるか、
	    セキュリティホールの回避方法が実行されるべきです。</para>
	</callout>

	<callout arearefs="co-solution">
	  <para><literal>Solution</literal> フィールドは、
	    影響のあるシステムにパッチを当てる手順を提供します。
	    ここではステップごとにシステムにパッチを当て、
	    安全に動作するように、
	    試験され検証された方法が記載されます。</para>
	</callout>

	<callout arearefs="co-details">
	  <para><literal>Correction Details</literal> フィールドは、
	    <acronym>CVS</acronym>
	    ブランチまたはリリース名のピリオドをアンダースコアに置き換えたものを示します。
	    ここでは、
	    各ブランチにおいて影響するファイルのリビジョン番号も示します。</para>
	</callout>

	<callout arearefs="co-ref">
	  <para><literal>References</literal> フィールドは、
	    通常、ウェブページの <acronym>URL</acronym>,
	    books, メーリングリストおよびニュースグループといった、
	    ほかの情報へのソースを提供します。</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 xml:id="security-accounting">
    <info><title>プロセスアカウンティング</title>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>寄稿: </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>プロセスアカウンティング</primary>
    </indexterm>

    <para>プロセスアカウンティングは、
      管理者が使用されているシステムのリソースを記録したり、
      リソースのユーザへの割り当て、
      システムのモニタリングおよびユーザのコマンドの最低限の記録を提供します。</para>

    <para>これは実際には、長所と短所があります。
      長所の一つは、侵入を入り口の時点で絞ることができます。
      短所は、プロセスアカウンティングにより生成されるログの量で、
      多くのディスク容量を必要とします。この節では、
      管理者を対象にプロセスアカウンティングの基礎を説明します。</para>

    <sect2>
      <title>プロセスアカウンティングを有効にする</title>

      <para>プロセスアカウンティングを使用する前に、
	プロセスアカウンティングを有効にしておく必要があります。
	有効にするには、以下のコマンドを実行してください。</para>

      <screen>&prompt.root; <userinput>touch <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>accton <filename>/var/account/acct</filename></userinput>

&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; <filename>/etc/rc.conf</filename></userinput></screen>

      <para>有効に設定すると、アカウンティングは、
	<acronym>CPU</acronym> の統計、コマンドなどの追跡を開始します。
	すべてのアカウンティングログは、
	人が読めるような形式ではないので、
	&man.sa.8; ユーティリティを使って見ることになります。
	オプションを設定せずに実行すると、
	<command>sa</command> はユーザコールの数、全経過時間 (分)、
	全 <acronym>CPU</acronym> およびユーザの時間 (分)、
	I/O 操作の平均数などを出力します。</para>

      <para>実行されたコマンドに関する情報を見るには、
	&man.lastcomm.1; ユーティリティを使ってください。
	<command>lastcomm</command> を使うと、
	ユーザが特定の &man.ttys.5; で実行したコマンドを出力できます。
	以下はその例です。</para>

      <screen>&prompt.root; <userinput>lastcomm ls
	<systemitem class="username">trhodes</systemitem> ttyp1</userinput></screen>

      <para>このコマンドを実行すると、ttyp1
	ターミナル上で <systemitem class="username">trhodes</systemitem>
	が実行した <command>ls</command>
	の使用について、記録されているすべて示します。</para>

      <para>他にも有用なオプションが多くあり、
	&man.lastcomm.1;, &man.acct.5; および &man.sa.8; マニュアルページで
	説明されています。</para>
    </sect2>
  </sect1>  
</chapter>
